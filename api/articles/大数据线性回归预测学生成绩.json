{"title":"大数据线性回归预测学生成绩","uid":"38a39c95773ebae43f0c0c8a85aadc04","slug":"大数据线性回归预测学生成绩","date":"2019-12-21T10:29:00.000Z","updated":"2020-07-01T01:54:32.000Z","comments":true,"path":"api/articles/大数据线性回归预测学生成绩.json","keywords":null,"cover":[],"content":"<p>通过训练集训练和测试集测试来生成多个线性模型，从而预测学生成绩，本文所有代码请点击<a href=\"https://github.com/wavecao/BigDataPredicteGrades\">Github</a></p>\n<h2 id=\"1-实验数据背景\"><a href=\"#1-实验数据背景\" class=\"headerlink\" title=\"1. 实验数据背景\"></a>1. 实验数据背景</h2><h3 id=\"1-1-数据来源\"><a href=\"#1-1-数据来源\" class=\"headerlink\" title=\"1.1  数据来源\"></a>1.1  数据来源</h3><p>本项目的数据来源于kaggle.com，数据集的名称为Student Grade Prediction，Paulo Cortez，Minho大学，葡萄牙吉马良斯，<a href=\"\">http：//www3.dsi.uminho.pt/pcortez</a></p>\n<h3 id=\"1-2-数据简介\"><a href=\"#1-2-数据简介\" class=\"headerlink\" title=\"1.2  数据简介\"></a>1.2  数据简介</h3><p>该数据接近了两所葡萄牙学校的中学学生的学习成绩。数据属性包括学生成绩，人口统计学，社会和与学校相关的特征），并通过使用学校报告和调查表进行收集。提供了两个关于两个不同学科表现的数据集：数学（mat）和葡萄牙语（por）</p>\n<p>该数据集共有396条，每列33个属性，属性简介如下：</p>\n<span id=\"more\"></span>\n\n<p>1.学校-学生学校（二进制：“ GP”-加布里埃尔·佩雷拉（Gabriel Pereira）或“ MS”-Mousinho da Silveira）</p>\n<p>2.性别-学生的性别（二进制：“ F”-女性或“ M”-男性）</p>\n<p>3.年龄-学生的年龄（数字：15至22）</p>\n<p>4.地址-学生的家庭住址类型（二进制：“ U”-城市或“ R”-农村）</p>\n<p>5.famsize-家庭大小（二进制：“ LE3”-小于或等于3或“ GT3”-大于3）</p>\n<p>6.Pstatus-父母的同居状态（二进制：“ T”-同居或“ A”-分开）</p>\n<p>7.Medu-母亲的教育（数字：0-无，1-初等教育（四年级），2 – 5至9年级，3 –中等教育或4 –高等教育）</p>\n<p>8.Fedu-父亲的教育（数字：0-无，1-初等教育（四年级），2 – 5至9年级，3 –中等教育或4 –高等教育）</p>\n<p>9.Mjob-母亲的工作（名义：“教师”，“与健康”有关的，民事“服务”（例如行政或警察），“在家”或“其他”）</p>\n<p>10.Fjob-父亲的工作（名义：“教师”，“与健康”相关的，民事“服务”（例如行政或警察），“在家”或“其他”）</p>\n<p>11.理由-选择这所学校的理由（名义：接近“家”，学校“声誉”，“课程”偏好或“其他”）</p>\n<p>12.监护人-学生的监护人（名词：“母亲”，“父亲”或“其他”）</p>\n<p>13.traveltime-学校到学校的旅行时间（数字：1-&lt;15分钟，2-15至30分钟，3-30分钟至1小时或4-&gt; 1小时）</p>\n<p>14.学习时间-每周学习时间（数字：1-&lt;2小时，2-2至5小时，3-5至10小时或4-&gt; 10小时）</p>\n<p>15.失败-过去类失败的次数（数字：如果1 &lt;= n &lt;3，则为n，否则为4）</p>\n<p>16.schoolup-额外的教育支持（二进制：是或否）</p>\n<p>17.famsup-家庭教育支持（二进制：是或否）</p>\n<p>18.付费-课程主题内的额外付费课程（数学或葡萄牙语）（二进制：是或否）</p>\n<p>19.活动-课外活动（二进制：是或否）</p>\n<p>20.托儿所-上托儿所（二进制：是或否）</p>\n<p>21.更高-想要接受高等教育（二进制：是或否）</p>\n<p>22.互联网-在家上网（二进制：是或否）</p>\n<p>23.浪漫-具有浪漫关系（二进制：是或否）</p>\n<p>24.家族-家庭关系的质量（数字：从1-非常差到5-极好）</p>\n<p>25.空闲时间-放学后的空闲时间（数字：从1-非常低到5-非常高）</p>\n<p>26.外出-与朋友外出（数字：从1-非常低到5-非常高）</p>\n<p>27.Dalc-工作日酒精消耗（数字：从1-非常低到5-非常高）</p>\n<p>28.Walc-周末酒精消耗（数字：从1-非常低至5-非常高）</p>\n<p>29.健康-当前的健康状况（数字：从1-非常差到5-非常好）</p>\n<p>30.缺勤-缺勤人数（数字：0到93）</p>\n<p>这些成绩与课程主题（数学或葡萄牙语）相关：</p>\n<p>31.G1-第一期成绩（数字：0至20）</p>\n<p>32.G2-第二学期成绩（数字：0至20）</p>\n<p>33.G3-最终成绩（数字：0到20，输出目标）</p>\n<h2 id=\"2-研究思路\"><a href=\"#2-研究思路\" class=\"headerlink\" title=\"2. 研究思路\"></a>2. 研究思路</h2><p>数据集中存在不少非数值型数据，所以在进行建模之前要进行数据清洗，主要是抛弃掉一些非相关性数据以及缺失值处理，对数据进行分析的时候要注意其中是否有缺失值。</p>\n<p>一些机器学习算法能够处理缺失值，比如神经网络，一些则不能。对于缺失值，一般有以下几种处理方法：</p>\n<p>（1）如果数据集很多，但有很少的缺失值，可以删掉带缺失值的行；</p>\n<p>（2）如果该属性相对学习来说不是很重要，可以对缺失值赋均值或者众数。</p>\n<p>（3）对于标称属性，可以赋一个代表缺失的值，比如‘U0’。因为缺失本身也可能代表着一些隐含信息。</p>\n<p>（4）使用回归 随机森林等模型来预测缺失属性的值。因为Age在该数据集里是一个相当重要的特征（先对Age进行分析即可得知），所以保证一定的缺失值填充准确率是非常重要的，对结果也会产生较大影响。一般情况下，会使用数据完整的条目作为模型的训练集，以此来预测缺失值。对于当前的这个数据，可以使用随机森林来预测也可以使用线性回归预测。这里使用随机森林预测模型，选取数据集中的数值属性作为特征（因为sklearn的模型只能处理数值属性，所以这里先仅选取数值特征，但在实际的应用中需要将非数值特征转换为数值特征）</p>\n<p>数据规范化后方可进行数据分析，本项目将首先拿出一些特定属性，通过绘制图标的形式单独分析该属性反映出来的信息，试图分析该属性对结果的影响。</p>\n<p>最后将对全部数据建立线性模型，并把数据集分为训练集和测试集，以测试模型的准确性。</p>\n<h2 id=\"3-具体步骤\"><a href=\"#3-具体步骤\" class=\"headerlink\" title=\"3. 具体步骤\"></a>3. 具体步骤</h2><h3 id=\"3-1-数据总体分析\"><a href=\"#3-1-数据总体分析\" class=\"headerlink\" title=\"3.1  数据总体分析\"></a>3.1  数据总体分析</h3><p>利用padans库的read_csv函数，可以读取数据集：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 初始化数据\nplt.rcParams[&#39;font.sans-serif&#39;] &#x3D; [&#39;SimHei&#39;]  # 中文字体设置-黑体\nplt.rcParams[&#39;axes.unicode_minus&#39;] &#x3D; False  # 解决保存图像是负号&#39;-&#39;显示为方块的问题\nsns.set(font&#x3D;&#39;SimHei&#39;)  # 解决Seaborn中文显示问题\nstudent &#x3D; pd.read_csv(&#39;student-mat.csv&#39;)</code></pre>\n\n<p>格式化后展示如图3-1-1</p>\n<p><img src=\"http://image.cheerway.fun/blog/20191221/ild5anDbNOI3.png?imageslim\"></p>\n<center>图3-1-1数据格式化</center>\n读取数据后，可以利用describe方法对单个属性分析，分析结果包括平均值，最值，标准差等，以G3属性为例，结果如图3-1-2所示\n\n<p><img src=\"http://image.cheerway.fun/blog/20191221/Rmp9PfDelzdP.png?imageslim\"></p>\n<center>图3-1-2 describe函数对单个属性分析</center>\n### 3.2  利用图表分析属性\n\n<h4 id=\"3-2-1各分数段学生计数\"><a href=\"#3-2-1各分数段学生计数\" class=\"headerlink\" title=\"3.2.1各分数段学生计数\"></a>3.2.1各分数段学生计数</h4><p>对学生期末成绩直接分析，可以得出成绩的大致分布，那么后文在分析其他因素对成绩的影响时也会更有针对性</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"> # 根据人数多少统计各分数段的学生人数 \n\ngrade_counts &#x3D; student[&#39;G3&#39;].value_counts().sort_values().plot.barh(width&#x3D;.9,color&#x3D;sns.color_palette(&#39;inferno&#39;,40)) \n\ngrade_counts.axes.set_title(&#39;各分数值的学生分布&#39;,fontsize&#x3D;30) \n\ngrade_counts.set_xlabel(&#39;学生数量&#39;, fontsize&#x3D;30) \n\ngrade_counts.set_ylabel(&#39;最终成绩&#39;, fontsize&#x3D;30) \n\nplt.show()</code></pre>\n\n<p>绘制出的图像如图3-2-1所示：</p>\n<p><img src=\"http://image.cheerway.fun/blog/20191221/fmFn0DCWkNTo.png?imageslim\"></p>\n<center>图3-2-1 各分数段学生统计图</center>\n#### 3.2.2 学生成绩分布直方图\n\n<p>3.2.1节中的图像并没有告诉我们有价值的信息，也许我们真正需要的是成绩分布直方图，即把成绩作为一个坐标轴，代码如下：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 从低到高展示成绩分布图 \ngrade_distribution &#x3D; sns.countplot(student[&#39;G3&#39;]) \ngrade_distribution.set_title(&#39;成绩分布图&#39;, fontsize&#x3D;30) \ngrade_distribution.set_xlabel(&#39;期末成绩&#39;, fontsize&#x3D;20) \ngrade_distribution.set_ylabel(&#39;人数统计&#39;, fontsize&#x3D;20) \nplt.show() </code></pre>\n\n<p>绘制出的图像如图3-2-2所示：</p>\n<p><img src=\"http://image.cheerway.fun/blog/20191221/JBzNlvOUolQM.png?imageslim\"></p>\n<center>图3-2-2 期末成绩分布图</center>\n可以看出得10分和11分的学生数量很多，虽然这只是一个中等成绩，大部分学生的成绩分布在8-15分之间。更值得注意的是，居然有接近40个人得了0分，不由得让我怀疑0其实是null值，但是在检查之后发现，确实是0值，外国学生这么菜？\n\n<h4 id=\"3-2-3-年龄因素分析\"><a href=\"#3-2-3-年龄因素分析\" class=\"headerlink\" title=\"3.2.3 年龄因素分析\"></a>3.2.3 年龄因素分析</h4><p>中学生正处在身体机能快速发育的时期，大脑亦是如此，不同智力水平的学生势必会得到不同的分数，因此有必要分析一下年龄对成绩的影响，并且考虑到性别因素。</p>\n<p>以下代码可以得出性别的相关数据：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 分析性别比例 \n\nmale_studs &#x3D; len(student[student[&#39;sex&#39;] &#x3D;&#x3D; &#39;M&#39;]) \n\nfemale_studs &#x3D; len(student[student[&#39;sex&#39;] &#x3D;&#x3D; &#39;F&#39;]) \n\nprint(&#39;男同学数量:&#39;,male_studs) \n\nprint(&#39;女同学数量:&#39;,female_studs)</code></pre>\n\n<p>结果为：男同学数量: 187，女同学数量: 208。男女比例并不悬殊。</p>\n<p>分析完性别因素之后，我们先来看看年龄比例的曲线图，代码如下：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 分析年龄分布比例（曲线图） \n\nage_distribution &#x3D; sns.kdeplot(student[&#39;age&#39;], shade&#x3D;True) \n\nage_distribution.axes.set_title(&#39;学生年龄分布图&#39;, fontsize&#x3D;30) \n\nage_distribution.set_xlabel(&#39;年龄&#39;, fontsize&#x3D;20) \n\nage_distribution.set_ylabel(&#39;比例&#39;, fontsize&#x3D;20) \n\nplt.show() </code></pre>\n\n<p>生成的图像如图3-2-3所示：</p>\n<p><img src=\"http://image.cheerway.fun/blog/20191221/7F9uhyjs0CxO.png?imageslim\"></p>\n<center>图3-2-3 年龄占比分布图</center>\n该图反映出一个重要的信息，那就是绝大部分学的年龄都在15-19岁之间，但是除此之外没有其他有价值的信息，甚至看不出各个年龄段的人数，最重要的是没有考虑年龄，因此我又绘制的分性别的年龄分布直方图，代码如下：\n\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 分性别年龄分布图（柱状图） \n\nage_distribution_sex &#x3D; sns.countplot(&#39;age&#39;, hue&#x3D;&#39;sex&#39;, data&#x3D;student) \n\nage_distribution_sex.axes.set_title(&#39;不同年龄段的学生人数&#39;, fontsize&#x3D;30) \n\nage_distribution_sex.set_xlabel(&#39;年龄&#39;, fontsize&#x3D;30) \n\nage_distribution_sex.set_ylabel(&#39;人数&#39;, fontsize&#x3D;30) \n\nplt.show() </code></pre>\n\n<p>绘制的图像如图3-2-4所示：</p>\n<p><img src=\"http://image.cheerway.fun/blog/20191221/af0Xk9BY2yE8.png?imageslim\"></p>\n<center>图3-2-4 分性别年龄分布图</center>\n结果就是，其实大部分学生的年龄是在15-18岁之间，并且各个年龄段的男女比例基本正常。超过该年龄的学生不一定是离群值，而是有年级下降的学生。分析完年龄本身，接下就可以分析年龄对成绩的影响，首先作出各年龄段的成绩箱型图，代码如下：\n\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 各年龄段的成绩箱型图 \n\nage_grade_boxplot &#x3D; sns.boxplot(x&#x3D;&#39;age&#39;, y&#x3D;&#39;G3&#39;, data&#x3D;student) \n\nage_grade_boxplot.axes.set_title(&#39;年龄与分数&#39;, fontsize &#x3D; 30) \n\nage_grade_boxplot.set_xlabel(&#39;年龄&#39;, fontsize &#x3D; 20) \n\nage_grade_boxplot.set_ylabel(&#39;分数&#39;, fontsize &#x3D; 20) \n\nplt.show() </code></pre>\n\n<p>得到的图像如图3-2-5所示：</p>\n<p><img src=\"http://image.cheerway.fun/blog/20191221/BDeffNFdGkli.png?imageslim\"></p>\n<center>图3-2-5 各年龄段的成绩箱型图</center>\n绘制分布而非统计图将有助于我们更好地理解数据，代码如下：\n\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 各年龄段的成绩分布图 \n\nage_grade_swarmplot &#x3D; sns.swarmplot(x&#x3D;&#39;age&#39;, y&#x3D;&#39;G3&#39;, data&#x3D;student) \n\nage_grade_swarmplot.axes.set_title(&#39;年龄与分数&#39;, fontsize &#x3D; 30) \n\nage_grade_swarmplot.set_xlabel(&#39;年龄&#39;, fontsize &#x3D; 20) \n\nage_grade_swarmplot.set_ylabel(&#39;分数&#39;, fontsize &#x3D; 20) \n\nplt.show() </code></pre>\n\n<p>得到的图像如图3-2-6所示：</p>\n<p><img src=\"http://image.cheerway.fun/blog/20191221/AY1BCX9ppuDq.png?imageslim\"></p>\n<center>图3-2-6 各年龄段的成绩分布图</center>\n在15-18这个主要年龄段，学生成绩在各分数段的分布基本一致，我们可以得出学生年龄与成绩并没有直接的关系，或者说关系很弱。\n\n<h4 id=\"3-2-4-学生城乡因素分析\"><a href=\"#3-2-4-学生城乡因素分析\" class=\"headerlink\" title=\"3.2.4 学生城乡因素分析\"></a>3.2.4 学生城乡因素分析</h4><p>既然年龄对成绩的影响不如预期那么明显，我们不妨再来分析一下学生地区因素对成绩的影响，在大部分地区，城乡教育资源都有不小的差距，教育质量也是如此，部分来自于乡下小学的孩子在步入城市中学后会不会落后于从小就在城市接受教育的孩子呢？</p>\n<p>首先分析城乡学生的比例，代码如下：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 城乡学生计数 \n\nareas_countplot &#x3D; sns.countplot(student[&#39;address&#39;]) \n\nareas_countplot.axes.set_title(&#39;城乡学生&#39;, fontsize &#x3D; 30) \n\nareas_countplot.set_xlabel(&#39;家庭住址&#39;, fontsize &#x3D; 20) \n\nareas_countplot.set_ylabel(&#39;计数&#39;, fontsize &#x3D; 20) \n\nplt.show() </code></pre>\n\n<p>绘制的图像如图3-2-7所示：</p>\n<p><img src=\"http://image.cheerway.fun/blog/20191221/fTXqHT6GIlty.png?imageslim\"></p>\n<center>图3-2-7 城乡学生分布图</center>\n​    大部分学生来自城市，并且城乡比例约为3 ：1。但是城市学生一定获得了更好的成绩吗？还需要进一步分析，代码如下：\n\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">sns.kdeplot(student.loc[student[&#39;address&#39;] &#x3D;&#x3D; &#39;U&#39;, &#39;G3&#39;], label&#x3D;&#39;Urban&#39;, shade &#x3D; True) \n\nsns.kdeplot(student.loc[student[&#39;address&#39;] &#x3D;&#x3D; &#39;R&#39;, &#39;G3&#39;], label&#x3D;&#39;Rural&#39;, shade &#x3D; True) \n\nplt.title(&#39;城市学生获得了更好的成绩吗？&#39;, fontsize &#x3D; 20) \n\nplt.xlabel(&#39;分数&#39;, fontsize &#x3D; 20) \n\nplt.ylabel(&#39;占比&#39;, fontsize &#x3D; 20) \n\nplt.show() </code></pre>\n\n<p>绘制出的图像如图3-2-8所示：</p>\n<p><img src=\"http://image.cheerway.fun/blog/20191221/J89RRLlMqbOW.png?imageslim\"></p>\n<center>图3-2-8 城乡学生成绩分布图</center>\n城乡学生成绩分布曲线的差别微乎其微，可见家庭住址的不同没有对成绩造成太大的影响。\n\n<h3 id=\"3-3-各属性与成绩的相关性分析\"><a href=\"#3-3-各属性与成绩的相关性分析\" class=\"headerlink\" title=\"3.3  各属性与成绩的相关性分析\"></a>3.3  各属性与成绩的相关性分析</h3><p>至此我们已经分析了年龄和地区这两个因素，然而并没有得到预期的结果——找出对成绩有影响的因素并分析原因，所以接下来我们综合分析各个因素与成绩之间的关系，希望会有好的结果。（注：仅限于数值属性）</p>\n<h4 id=\"3-3-1相关性初步计算\"><a href=\"#3-3-1相关性初步计算\" class=\"headerlink\" title=\"3.3.1相关性初步计算\"></a>3.3.1相关性初步计算</h4><p>首先计算出各个属性与最终成绩G3的相关性，只需一行代码：</p>\n<p>student.corr()[‘G3’].sort_values() </p>\n<p>结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\\1.  failures   -0.360415 \n\n\\2.  age     -0.161579 \n\n\\3.  goout    -0.132791 \n\n\\4.  traveltime  -0.117142 \n\n\\5.  health    -0.061335 \n\n\\6.  Dalc     -0.054660 \n\n\\7.  Walc     -0.051939 \n\n\\8.  freetime   0.011307 \n\n\\9.  absences   0.034247 \n\n\\10. famrel    0.051363 \n\n\\11. studytime   0.097820 \n\n\\12. Fedu     0.152457 \n\n\\13. Medu     0.217147 \n\n\\14. G1      0.801468 \n\n\\15. G2      0.904868 \n\n\\16. G3      1.000000 \n\n\\17. Name: G3, dtype: float64</code></pre>\n\n<p>绝大部分机器学习算法无法处理非数值数据，因此在进行机器学习之前，我们要对部分属性进行编码。</p>\n<p>首先介绍一下编码方式，第一种是标签编码：</p>\n<p>此方法会为每个类别分配一个标签（label）</p>\n<table>\n<thead>\n<tr>\n<th>Occupation</th>\n<th>Label</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Programmer</td>\n<td>0</td>\n</tr>\n<tr>\n<td>Data  Scientist</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Engineer</td>\n<td>2</td>\n</tr>\n</tbody></table>\n<p>​    标签编码的问题是整数的分配是随机的，并且每次运行函数时都会改变。 此外，模型可能会为更大的标签赋予更高的优先级。当我们只有2个唯一值时，可以使用标签编码。</p>\n<p>第二种是独热编码：</p>\n<p>它为每个类别创建一个新列，并且仅使用二进制值。独热编码的缺点是，如果分类变量具有许多类别，则特征数量可能会爆炸。为了解决这个问题，我们可以执行PCA（或其他降维方法），然后执行独热编码。</p>\n<table>\n<thead>\n<tr>\n<th>Occupation</th>\n<th>Occupation_prog</th>\n<th>Occupation_ds</th>\n<th>Occupation_eng</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Programmer</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>Data  Scientist</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>Enginner</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n</tr>\n</tbody></table>\n<h4 id=\"3-3-2-编码后的相关性计算\"><a href=\"#3-3-2-编码后的相关性计算\" class=\"headerlink\" title=\"3.3.2 编码后的相关性计算\"></a>3.3.2 编码后的相关性计算</h4><p>​    利用独热编码处理我们的数据集，然后再次寻找相关性，尽管G1和G2是学生的期末成绩，并且与期末成绩G3高度相关，但我们将其删除。没有G2和G1的情况下预测G3更加困难，但是这种预测更加有用，因为我们希望找到影响成绩的其他因素。代码如下：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 选取G3属性值 \n\nlabels &#x3D; student[&#39;G3&#39;] \n\n# 删除school，G1和G2属性 \n\nstudent &#x3D; student.drop([&#39;school&#39;, &#39;G1&#39;, &#39;G2&#39;], axis&#x3D;&#39;columns&#39;) \n\n# 对离散变量进行独热编码 \n\nstudent &#x3D; pd.get_dummies(student) \n\n# 选取相关性最强的6个 \n\nmost_correlated &#x3D; student.corr().abs()[&#39;G3&#39;].sort_values(ascending&#x3D;False) \n\nmost_correlated &#x3D; most_correlated[:6] \n\nprint(most_correlated) </code></pre>\n\n<p>输出的结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\\1.  G3       1.000000 \n\n\\2.  failures    0.360415 \n\n\\3.  Medu      0.217147 \n\n\\4.  higher_yes   0.182465 \n\n\\5.  higher_no   0.182465 \n\n\\6.  age      0.161579 \n\n\\7.  Fedu      0.152457  \n\n\\8.  Name: G3, dtype: float64 </code></pre>\n\n\n\n<h3 id=\"3-4-高相关度属性对成绩的影响\"><a href=\"#3-4-高相关度属性对成绩的影响\" class=\"headerlink\" title=\"3.4  高相关度属性对成绩的影响\"></a>3.4  高相关度属性对成绩的影响</h3><h4 id=\"3-4-1-失败次数对成绩的影响\"><a href=\"#3-4-1-失败次数对成绩的影响\" class=\"headerlink\" title=\"3.4.1 失败次数对成绩的影响\"></a>3.4.1 失败次数对成绩的影响</h4><p>​    代码如下：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 失败次数成绩分布图 \n\nfailures_swarmplot &#x3D; sns.swarmplot(x&#x3D;student[&#39;failures&#39;],y&#x3D;student[&#39;G3&#39;]) \n\nfailures_swarmplot.axes.set_title(&#39;失败次数少的学生分数更高吗？&#39;, fontsize &#x3D; 30) \n\nfailures_swarmplot.set_xlabel(&#39;失败次数&#39;, fontsize &#x3D; 20) \n\nfailures_swarmplot.set_ylabel(&#39;最终成绩&#39;, fontsize &#x3D; 20) \n\nplt.show() </code></pre>\n\n<p>生成的图像如图3-4-1所示：</p>\n<p><img src=\"http://image.cheerway.fun/blog/20191221/FPhpSE69gNUL.png?imageslim\"></p>\n<center>图3-4-1 失败次数对成绩的影响</center>\n​    结果很明显，失败次数少的学生其成绩分布图更偏向于高分，可见失败次数少的学生更容易拿到高分，这或许是因为失败次数少的学生自信心更强。\n\n<h4 id=\"3-4-2-双亲受教育水平对成绩的影响\"><a href=\"#3-4-2-双亲受教育水平对成绩的影响\" class=\"headerlink\" title=\"3.4.2 双亲受教育水平对成绩的影响\"></a>3.4.2 双亲受教育水平对成绩的影响</h4><p>​    代码如下：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 双亲受教育水平的影响 \n\nfamily_ed &#x3D; student[&#39;Fedu&#39;] + student[&#39;Medu&#39;]  \n\nfamily_ed_boxplot &#x3D; sns.boxplot(x&#x3D;family_ed,y&#x3D;student[&#39;G3&#39;]) \n\nfamily_ed_boxplot.axes.set_title(&#39;双亲受教育水平的影响&#39;, fontsize &#x3D; 30) \n\nfamily_ed_boxplot.set_xlabel(&#39;家庭教育水平(Mother + Father)&#39;, fontsize &#x3D; 20) \n\nfamily_ed_boxplot.set_ylabel(&#39;最终成绩&#39;, fontsize &#x3D; 20) \n\nplt.show() </code></pre>\n\n<p>生成的图像如图3-4-2所示：</p>\n<p><img src=\"http://image.cheerway.fun/blog/20191221/bL7WV6bLSlzd.png?imageslim\"></p>\n<center>图3-4-2 双亲受教育水平对成绩的影响</center>\n​    可见在一定范围内，随着家庭教育水平的提升，学生的平均成绩也有所提升，但是在图表的两极却出现了规律的之外的东西，家庭受教育水平最低的学生，最终成绩高于不少其他水平的家庭，而家庭受教育水平最高的家庭，孩子的成绩却不是最高。原因暂时不明，且不排除数据错误的可能。\n\n<h4 id=\"3-4-3-学生升学意愿对成绩的影响\"><a href=\"#3-4-3-学生升学意愿对成绩的影响\" class=\"headerlink\" title=\"3.4.3 学生升学意愿对成绩的影响\"></a>3.4.3 学生升学意愿对成绩的影响</h4><p>高等教育是绝对变量，其值为是和否。 由于我们使用了独热编码，因此已将其转换为2个变量。 因此，我们可以消除其中之一（因为这些值是互补的）。 我们消除Higher_no，因为Higher_yes更直观。</p>\n<p>​    代码如下：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 学生自己的升学意志对成绩的影响 \n\npersonal_wish &#x3D; sns.boxplot(x &#x3D; student[&#39;higher_yes&#39;], y&#x3D;student[&#39;G3&#39;]) \n\npersonal_wish.axes.set_title(&#39;学生升学意愿对成绩的影响&#39;, fontsize &#x3D; 30) \n\npersonal_wish.set_xlabel(&#39;更高级的教育 (1 &#x3D; 是)&#39;, fontsize &#x3D; 20) \n\npersonal_wish.set_ylabel(&#39;最终成绩&#39;, fontsize &#x3D; 20) \n\nplt.show() </code></pre>\n\n<p>生成的图像如图3-4-3所示：</p>\n<p><img src=\"http://image.cheerway.fun/blog/20191221/H6V25vVk1T1V.png?imageslim\"></p>\n<p>图3-4-3 学生自己的升学意志对成绩的影响</p>\n<p>显而易见，如果学生本人渴望受到更高的教育，其成绩也会更高一些，毕竟学习是自己的事情。</p>\n<h3 id=\"3-5-大数据模型\"><a href=\"#3-5-大数据模型\" class=\"headerlink\" title=\"3.5  大数据模型\"></a>3.5  大数据模型</h3><h4 id=\"3-5-1-数据分割\"><a href=\"#3-5-1-数据分割\" class=\"headerlink\" title=\"3.5.1   数据分割\"></a>3.5.1   数据分割</h4><p>在大数据通过机器学习建立模型的过程中，不仅要使用大量的数据来训练模型，还需要一定数量的测试集验证模型的准确性，从而判断模型是否可用。因此，我们将数据集分割成训练集和测试集，比例分别为75%和25%。只需一行代码：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">X_train, X_test, y_train, y_test &#x3D; train_test_split(student, labels, test_size &#x3D; 0.25, random_state&#x3D;42) </code></pre>\n\n<p>分割后我们便可以利用数据集进行线性回归模型的训练。</p>\n<h4 id=\"3-5-2-训练之前的准备工作\"><a href=\"#3-5-2-训练之前的准备工作\" class=\"headerlink\" title=\"3.5.2   训练之前的准备工作\"></a>3.5.2   训练之前的准备工作</h4><p>代码中的注释已经足够详细，不做解释，直接贴代码：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 计算平均绝对误差和均方根误差 \n\n# MAE-平均绝对误差 \n\n# RMSE-均方根误差 \n\ndef evaluate_predictions(predictions, true): \n\n    mae &#x3D; np.mean(abs(predictions - true)) \n\n    rmse &#x3D; np.sqrt(np.mean((predictions - true) ** 2)) \n\n     \n\n    return mae, rmse \n\n   \n\n # 求中位数 \n\n median_pred &#x3D; X_train[&#39;G3&#39;].median() \n\n  \n\n # 所有中位数的列表 \n\n median_preds &#x3D; [median_pred **for** _ **in** range(len(X_test))] \n\n  \n\n # 存储真实的G3值以传递给函数 \n\n true &#x3D; X_test[&#39;G3&#39;] \n\n  \n\n# 展示基准的原始指标 \n\n mb_mae, mb_rmse &#x3D; evaluate_predictions(median_preds, true) \n\nprint(&#39;Median Baseline MAE: &#123;:.4f&#125;&#39;.format(mb_mae)) \n\nprint(&#39;Median Baseline RMSE: &#123;:.4f&#125;&#39;.format(mb_rmse)) </code></pre>\n\n<p>最后两句代码的运行结果为：</p>\n<p>Median Baseline MAE: 3.7879</p>\n<p>Median Baseline RMSE: 4.8252</p>\n<h4 id=\"3-5-3-预测模型训练\"><a href=\"#3-5-3-预测模型训练\" class=\"headerlink\" title=\"3.5.3   预测模型训练\"></a>3.5.3   预测模型训练</h4><p>本项目将试图训练出六种模型，分别为：线性回归，ElasticNet回归，随机森林，极端随机数，支持向量机（SVM），梯度提升树。</p>\n<p>代码如下：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 通过训练集训练和测试集测试来生成多个线性模型\ndef evaluate(X_train, X_test, y_train, y_test):\n    # 模型名称\n    model_name_list &#x3D; [&#39;Linear Regression&#39;, &#39;ElasticNet Regression&#39;,\n                      &#39;Random Forest&#39;, &#39;Extra Trees&#39;, &#39;SVM&#39;,\n                       &#39;Gradient Boosted&#39;, &#39;Baseline&#39;]\n    X_train &#x3D; X_train.drop(&#39;G3&#39;, axis&#x3D;&#39;columns&#39;)\n    X_test &#x3D; X_test.drop(&#39;G3&#39;, axis&#x3D;&#39;columns&#39;)\n    \n    # 实例化模型\n    model1 &#x3D; LinearRegression()\n    model2 &#x3D; ElasticNet(alpha&#x3D;1.0, l1_ratio&#x3D;0.5)\n    model3 &#x3D; RandomForestRegressor(n_estimators&#x3D;100)\n    model4 &#x3D; ExtraTreesRegressor(n_estimators&#x3D;100)\n    model5 &#x3D; SVR(kernel&#x3D;&#39;rbf&#39;, degree&#x3D;3, C&#x3D;1.0, gamma&#x3D;&#39;auto&#39;)\n    model6 &#x3D; GradientBoostingRegressor(n_estimators&#x3D;50)\n    \n    # 结果数据框\n    results &#x3D; pd.DataFrame(columns&#x3D;[&#39;mae&#39;, &#39;rmse&#39;], index &#x3D; model_name_list)\n    \n    # 每种模型的训练和预测\n    for i, model in enumerate([model1, model2, model3, model4, model5, model6]):\n        model.fit(X_train, y_train)\n        predictions &#x3D; model.predict(X_test)\n        \n        # 误差标准\n        mae &#x3D; np.mean(abs(predictions - y_test))\n        rmse &#x3D; np.sqrt(np.mean((predictions - y_test) ** 2))\n        \n        # 将结果插入结果框\n        model_name &#x3D; model_name_list[i]\n        results.loc[model_name, :] &#x3D; [mae, rmse]\n    \n    # 中值基准度量\n    baseline &#x3D; np.median(y_train)\n    baseline_mae &#x3D; np.mean(abs(baseline - y_test))\n    baseline_rmse &#x3D; np.sqrt(np.mean((baseline - y_test) ** 2))\n    \n    results.loc[&#39;Baseline&#39;, :] &#x3D; [baseline_mae, baseline_rmse]\n    \n    return results\nresults &#x3D; evaluate(X_train, X_test, y_train, y_test)\nprint(results)</code></pre>\n\n<p>结果如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>模型名称</th>\n<th>MAE-平均绝对误差</th>\n<th>RMSE-均方根误差</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Linear Regression</td>\n<td>3.41954</td>\n<td>4.27557</td>\n</tr>\n<tr>\n<td>ElasticNet Regression</td>\n<td>3.62976</td>\n<td>4.58258</td>\n</tr>\n<tr>\n<td>Random Forest</td>\n<td>3.04111</td>\n<td>3.77742</td>\n</tr>\n<tr>\n<td>Extra Trees</td>\n<td>3.14586</td>\n<td>4.05109</td>\n</tr>\n<tr>\n<td>SVM</td>\n<td>3.50899</td>\n<td>4.38375</td>\n</tr>\n<tr>\n<td>Gradient Boosted</td>\n<td>3.19128</td>\n<td>4.00822</td>\n</tr>\n<tr>\n<td>Baseline</td>\n<td>3.78788</td>\n<td>4.82523</td>\n</tr>\n</tbody></table>\n<p>至此模型的训练已经完成，后续的分析将在第五节中呈现。</p>\n<h2 id=\"4-分析与总结\"><a href=\"#4-分析与总结\" class=\"headerlink\" title=\"4. 分析与总结\"></a>4. 分析与总结</h2><p>模型训练完成之后，并非全部工作完成了，我们在第四节的最后训练出了多个模型，但是模型也有准确率之别，我们下一步就是要找出最合适的模型，代码如下:</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 找出最合适的模型\nplt.figure(figsize&#x3D;(12, 8))\n\n# 平均绝对误差\nax &#x3D;  plt.subplot(1, 2, 1)\nresults.sort_values(&#39;mae&#39;, ascending &#x3D; True).plot.bar(y &#x3D; &#39;mae&#39;, color &#x3D; &#39;b&#39;, ax &#x3D; ax, fontsize&#x3D;20)\nplt.title(&#39;平均绝对误差&#39;, fontsize&#x3D;20) \nplt.ylabel(&#39;MAE&#39;, fontsize&#x3D;20)\n\n# 均方根误差\nax &#x3D; plt.subplot(1, 2, 2)\nresults.sort_values(&#39;rmse&#39;, ascending &#x3D; True).plot.bar(y &#x3D; &#39;rmse&#39;, color &#x3D; &#39;r&#39;, ax &#x3D; ax, fontsize&#x3D;20)\nplt.title(&#39;均方根误差&#39;, fontsize&#x3D;20) \nplt.ylabel(&#39;RMSE&#39;,fontsize&#x3D;20)\nplt.tight_layout()\nplt.show()</code></pre>\n\n<p>生成的图像如图4-1所示：</p>\n<p><img src=\"http://image.cheerway.fun/blog/20191221/dIc1MXKhIIuA.png?imageslim\"></p>\n<center>图4-1 各模型误差柱状图</center>\n显然，无论是平均绝对误差还是均方根误差，线性回归模型都是最小的。因此我们对它进行保存，以便于以后调用，代码很简单：\n\n<p>*</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 保存线性回归模型*\n\nmodel &#x3D; LinearRegression()\n\nmodel.fit(X_train, y_train)\n\nfilename &#x3D; &#39;LR_Model&#39;\n\npickle.dump(model, open(filename, &#39;wb&#39;)) </code></pre>\n\n<p>至此，建立大数据模型的工作已经全部完毕，并且保存了我们训练好的模型，以后如果想预测某个学生的成绩，只要将相关属性输入模型即可得出预测结果。</p>\n<p>回过头来再想一下，大数据学习的初衷是数据分析，因此在建立模型之前，有必要对单个属性先进行一些分析，毕竟在某些数据集中可能会存在一些影响性大甚至是决定性的属性。但对属性分析不意味着随便拿属性分析，除了理性选择之外，我们最好提前把数据进行编码，然后分析各个属性的相关性，选取一些相关性较高的属性分析。比如本项目中，失败次数，学生个人升学意愿对学生的成绩影响非常明显。</p>\n<p>需要强调的是，基于大数据的预测并不是绝对准确的，很多时候由于各种原因可能会造成离谱的误差，因此它只是我们预测结果的参考值。</p>\n","text":"通过训练集训练和测试集测试来生成多个线性模型，从而预测学生成绩，本文所有代码请点击Github 1. 实验数据背景1.1 数据来源本项目的数据来源于kaggle.com，数据集的名称为Student Grade Prediction，Paulo Cortez，Minho大学，葡萄...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"大数据","slug":"大数据","count":1,"path":"api/categories/大数据.json"},{"name":"算法","slug":"大数据/算法","count":1,"path":"api/categories/大数据/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"},{"name":"大数据","slug":"大数据","count":1,"path":"api/tags/大数据.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%AE%9E%E9%AA%8C%E6%95%B0%E6%8D%AE%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">1. 实验数据背景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90\"><span class=\"toc-text\">1.1  数据来源</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E6%95%B0%E6%8D%AE%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">1.2  数据简介</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%A0%94%E7%A9%B6%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">2. 研究思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">3. 具体步骤</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E6%95%B0%E6%8D%AE%E6%80%BB%E4%BD%93%E5%88%86%E6%9E%90\"><span class=\"toc-text\">3.1  数据总体分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-1%E5%90%84%E5%88%86%E6%95%B0%E6%AE%B5%E5%AD%A6%E7%94%9F%E8%AE%A1%E6%95%B0\"><span class=\"toc-text\">3.2.1各分数段学生计数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-3-%E5%B9%B4%E9%BE%84%E5%9B%A0%E7%B4%A0%E5%88%86%E6%9E%90\"><span class=\"toc-text\">3.2.3 年龄因素分析</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-4-%E5%AD%A6%E7%94%9F%E5%9F%8E%E4%B9%A1%E5%9B%A0%E7%B4%A0%E5%88%86%E6%9E%90\"><span class=\"toc-text\">3.2.4 学生城乡因素分析</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-%E5%90%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%88%90%E7%BB%A9%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%E5%88%86%E6%9E%90\"><span class=\"toc-text\">3.3  各属性与成绩的相关性分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-1%E7%9B%B8%E5%85%B3%E6%80%A7%E5%88%9D%E6%AD%A5%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">3.3.1相关性初步计算</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-2-%E7%BC%96%E7%A0%81%E5%90%8E%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">3.3.2 编码后的相关性计算</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-%E9%AB%98%E7%9B%B8%E5%85%B3%E5%BA%A6%E5%B1%9E%E6%80%A7%E5%AF%B9%E6%88%90%E7%BB%A9%E7%9A%84%E5%BD%B1%E5%93%8D\"><span class=\"toc-text\">3.4  高相关度属性对成绩的影响</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-1-%E5%A4%B1%E8%B4%A5%E6%AC%A1%E6%95%B0%E5%AF%B9%E6%88%90%E7%BB%A9%E7%9A%84%E5%BD%B1%E5%93%8D\"><span class=\"toc-text\">3.4.1 失败次数对成绩的影响</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-2-%E5%8F%8C%E4%BA%B2%E5%8F%97%E6%95%99%E8%82%B2%E6%B0%B4%E5%B9%B3%E5%AF%B9%E6%88%90%E7%BB%A9%E7%9A%84%E5%BD%B1%E5%93%8D\"><span class=\"toc-text\">3.4.2 双亲受教育水平对成绩的影响</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-3-%E5%AD%A6%E7%94%9F%E5%8D%87%E5%AD%A6%E6%84%8F%E6%84%BF%E5%AF%B9%E6%88%90%E7%BB%A9%E7%9A%84%E5%BD%B1%E5%93%8D\"><span class=\"toc-text\">3.4.3 学生升学意愿对成绩的影响</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">3.5  大数据模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-5-1-%E6%95%B0%E6%8D%AE%E5%88%86%E5%89%B2\"><span class=\"toc-text\">3.5.1   数据分割</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-5-2-%E8%AE%AD%E7%BB%83%E4%B9%8B%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C\"><span class=\"toc-text\">3.5.2   训练之前的准备工作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-5-3-%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83\"><span class=\"toc-text\">3.5.3   预测模型训练</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">4. 分析与总结</span></a></li></ol>","author":{"name":"Cao Wei","slug":"blog-author","avatar":"https://uploadfiles.nowcoder.com/images/20210823/575528905_1629692577639/4B05D951868901CDA3382C7B70543CD5","link":"/","description":"Code makes world better","socials":{"github":"https://github.com/wavecao","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"SpringBoot-HelloWorld","uid":"7039c293fbb0465a1b618eb4fc99fd7e","slug":"SpringBoot入门-HelloWorld","date":"2020-02-26T08:32:00.000Z","updated":"2020-07-01T01:52:16.000Z","comments":true,"path":"api/articles/SpringBoot入门-HelloWorld.json","keywords":null,"cover":"http://image.cheerway.fun/blog/20200225/Wrc0uF8i5r3r.png?imageslim","text":"SpringBoot-HelloWorld1. 为什么要用SpringBoot相信用过SSM框架的小伙伴都知道，在使用过程中我们必须配置大量的.xml文件来整合各个框架并对其参数进行配置，这项工作对于大型项目来说苦不堪言。 于是Pivotal 团队提供了全新的框架Spring Boot，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架采用“习惯优于配置”的方式开发，可以快速构建Spring应用。 SpringBoot 主要有以下优点： 快速创建独立运行的Spring项目以及与主流框架集成 使用嵌入式的Servlet容器，应用无需打成WAR包 starters自动依赖与版...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"SpringBoot","slug":"SpringBoot","count":3,"path":"api/categories/SpringBoot.json"}],"tags":[{"name":"笔记","slug":"笔记","count":11,"path":"api/tags/笔记.json"},{"name":"SpringBoot","slug":"SpringBoot","count":3,"path":"api/tags/SpringBoot.json"}],"author":{"name":"Cao Wei","slug":"blog-author","avatar":"https://uploadfiles.nowcoder.com/images/20210823/575528905_1629692577639/4B05D951868901CDA3382C7B70543CD5","link":"/","description":"Code makes world better","socials":{"github":"https://github.com/wavecao","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"【算法】Python判断数字是否是回文数","uid":"70047dfd85b8c57f6b791b919373d4bb","slug":"【算法】Python判断数字是否是回文数","date":"2019-12-12T03:56:00.000Z","updated":"2020-02-25T03:57:22.000Z","comments":true,"path":"api/articles/【算法】Python判断数字是否是回文数.json","keywords":null,"cover":null,"text":"回文数的定义：回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例1： 输入：121 输出：True 示例2： 输入：-121 输出：False 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例3： 输入: 10 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":2,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"}],"author":{"name":"Cao Wei","slug":"blog-author","avatar":"https://uploadfiles.nowcoder.com/images/20210823/575528905_1629692577639/4B05D951868901CDA3382C7B70543CD5","link":"/","description":"Code makes world better","socials":{"github":"https://github.com/wavecao","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}