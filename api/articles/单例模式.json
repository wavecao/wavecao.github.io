{"title":"单例模式详解","uid":"a38aadce42dddbcde7f41fcb5e12b8a9","slug":"单例模式","date":"2020-07-28T09:02:00.000Z","updated":"2020-07-28T09:03:02.000Z","comments":true,"path":"api/articles/单例模式.json","keywords":null,"cover":null,"content":"<h1 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h1><h2 id=\"一、什么是单例模式\"><a href=\"#一、什么是单例模式\" class=\"headerlink\" title=\"一、什么是单例模式\"></a>一、什么是单例模式</h2><ul>\n<li>单例类只能有一个实例</li>\n<li>必须自行创建自己的唯一实例</li>\n<li>向所有其他对象提供这一实例</li>\n</ul>\n<h2 id=\"二、单例模式的分类\"><a href=\"#二、单例模式的分类\" class=\"headerlink\" title=\"二、单例模式的分类\"></a>二、单例模式的分类</h2><p><strong>饿汉式：</strong>在类加载时候就创建单例（不管是否需要使用，都会先创建）</p>\n<p><strong>懒汉式：</strong>在需要使用实例的时候才创建</p>\n<h2 id=\"三、代码实现\"><a href=\"#三、代码实现\" class=\"headerlink\" title=\"三、代码实现\"></a>三、代码实现</h2><p>单例模式的核心思想：</p>\n<ul>\n<li>定义私有静态对象作为该类的唯一实例obj。</li>\n<li>私有化构造函数，保证用户不可以直接通过构造函数创建该类实例，或直接访问该类实例。</li>\n<li>定义一个公有的getInstance()方法去获得该类的唯一单例obj。</li>\n</ul>\n<h3 id=\"饿汉式：\"><a href=\"#饿汉式：\" class=\"headerlink\" title=\"饿汉式：\"></a>饿汉式：</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>静态常量：将唯一实例instance设置为静态常量</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton1 &#123;\n    private static final Singleton1 INSTANCE &#x3D; new Singleton1();\n    private Singleton1() &#123;\n        System.out.println(&quot;单例模式懒汉式(静态常量)——我被new出来了&quot;);\n    &#125;\n    public static Singleton1 getInstance() &#123;\n        return INSTANCE;\n    &#125;\n&#125;</code></pre>\n\n<p>特点：多线程下可以保证是唯一实例，但是造成了资源浪费，因为有时候我们可能不需要这个实例</p>\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>静态代码块：将类的实例化放在静态代码块中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton2 &#123;\n    private static Singleton2 instance;\n    static &#123;\n        instance &#x3D; new Singleton2();\n    &#125;\n    private Singleton2() &#123;\n        System.out.println(&quot;单例模式懒汉式(静态代码块)——我被new出来了&quot;);\n    &#125;\n\n    public static Singleton2 getInstance() &#123;\n        return instance;\n    &#125;\n&#125;</code></pre>\n\n<p>特点：与方法一相同</p>\n<h4 id=\"方法三\"><a href=\"#方法三\" class=\"headerlink\" title=\"方法三\"></a>方法三</h4><p>静态内部类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton3 &#123;\n    private Singleton3() &#123;\n        System.out.println(&quot;单例模式懒汉式(静态内部类)——我被new出来了&quot;);\n    &#125;\n    public static class SingletonInstance &#123;\n        private static final Singleton3 instance &#x3D; new Singleton3();\n    &#125;\n    public static Singleton3 getInstance() &#123;\n        return SingletonInstance.instance;\n    &#125;\n&#125;</code></pre>\n\n<p>特点：Singleton3在加载的时候不会被实例化，而是在需要实例化时（调用getInstance()）,才会装载静态内部类，从而完成Singleton2的实例化。多线程下可以实现单例。</p>\n<h3 id=\"懒汉式：\"><a href=\"#懒汉式：\" class=\"headerlink\" title=\"懒汉式：\"></a>懒汉式：</h3><h4 id=\"方法一-1\"><a href=\"#方法一-1\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>只判断一次+不加任何同步锁 多线程下不能实现单例，<strong>错误示范！</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton4 &#123;\n    private static Singleton4 instance &#x3D; null;\n    private Singleton4() &#123;\n        System.out.println(&quot;实例被new出来了&quot;);\n    &#125;\n    public static Singleton4 getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new Singleton4();\n        &#125;\n        return instance;\n    &#125;\n&#125;</code></pre>\n\n<p>该方式<strong>不能保证</strong>高并发下的单个实例：比如线程1运行到if (instance == null)这行代码，还没来得及运行下一行创建实例的代码，此时线程2获得CPU时间片，恰好也运行到这个判断条件，就同样得到一个true结果，因此出现了两个实例！！！</p>\n<h4 id=\"方法二-1\"><a href=\"#方法二-1\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>用synchronized对getInstance()方法加锁，可以实现单例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton5 &#123;\n    private static Singleton5 instance &#x3D; null;\n    private Singleton5() &#123;\n        System.out.println(&quot;实例被new出来了&quot;);\n    &#125;\n    public static synchronized Singleton5 getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new Singleton5();\n        &#125;\n        return instance;\n    &#125;\n&#125;</code></pre>\n\n<p>缺点：这样给整个方法都加上了同步锁，即每次想得到一次单例都会给此方法加锁，这样使线程之间退化成串行化的执行。上面方法效率太低，我希望只在该方法执行第一次实例化的时候加锁，如果该单例已被new出，则不进入同步区域，直接返回即可。</p>\n<h4 id=\"方法三-1\"><a href=\"#方法三-1\" class=\"headerlink\" title=\"方法三\"></a>方法三</h4><p>用synchronized对类加同步锁+双重检查  这个看测试结果似乎能实现单例，但其实没有volatile修饰的obj实例的这个类也是一个<strong>错误方法！</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton6 &#123;\n    private static Singleton6 instance &#x3D; null;\n    private Singleton6() &#123;\n        System.out.println(&quot;实例被new出来了&quot;);\n    &#125;\n    public static Singleton6 getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            synchronized (Singleton6.class) &#123;\n                if (instance &#x3D;&#x3D; null) &#123;\n                    instance &#x3D; new Singleton6(); &#x2F;&#x2F;error\n                &#125;\n            &#125;\n        &#125;\n        return instance;\n    &#125;\n&#125;</code></pre>\n\n<p>双重检查锁：</p>\n<p>第一次检查instance是否被初始化（不去获得锁，只是查看是否满足加锁的条件而言），若已被初始化则返回。</p>\n<p>第二次检查instance查看在加锁阻塞期间，是否已经有其他线程先一步对instance做了初始化。</p>\n<p>这样看来似乎单例没问题呀，但其实这里有一个隐患，对构造函数来说，编译器为了优化进行指令重排序：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>实例化对象的那行代码（注释为为error的那行），实际上可以分解成以下三个步骤：</p>\n<ol>\n<li>分配内存空间</li>\n<li>初始化对象</li>\n<li>将对象指向刚分配的内存空间</li>\n</ol>\n<p>但是有些编译器为了性能的原因，可能会将第二步和第三步进行<strong>重排序</strong>，顺序就成了：</p>\n<ol>\n<li>分配内存空间</li>\n<li>将对象指向刚分配的内存空间</li>\n<li>初始化对象</li>\n</ol></blockquote>\n<p>因此整个过程可能会变成如下场景：</p>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>Thread A</th>\n<th>Thread B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>S1</td>\n<td>检查到对象instance为空</td>\n<td></td>\n</tr>\n<tr>\n<td>S2</td>\n<td>获取类的同步锁</td>\n<td></td>\n</tr>\n<tr>\n<td>S3</td>\n<td>再次检查到instance为空</td>\n<td></td>\n</tr>\n<tr>\n<td>S4</td>\n<td>为instance分配内存空间</td>\n<td></td>\n</tr>\n<tr>\n<td>S5</td>\n<td>将instance指向刚分配的内存空间</td>\n<td></td>\n</tr>\n<tr>\n<td>S6</td>\n<td></td>\n<td>检查到对象instance不为空</td>\n</tr>\n<tr>\n<td>S7</td>\n<td></td>\n<td>访问并返回instance（此时对象还未初始化，得到一个初始化未完成的对象）</td>\n</tr>\n<tr>\n<td>S8</td>\n<td>初始化instance</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>表格中，S7时刻线程B对instance的访问，访问的是一个初始化未完成的对象，发生错误。 </p>\n<h4 id=\"方法四\"><a href=\"#方法四\" class=\"headerlink\" title=\"方法四\"></a>方法四</h4><p>双重校验+volatile</p>\n<p>双重校验+volatile 与上一个类不同的是，该类中对这个单例obj加了volatile关键字。这个关键字的作用是：使用了volatile关键字后，重排序被禁止，所有的写（write）操作都将发生在读（read）操作之前。在volatile和synchronized两端线程安全的保护下，保证多线程下单例的创建。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton7 &#123;\n    private static volatile Singleton7 instance &#x3D; null;\n    private Singleton7() &#123;\n        System.out.println(&quot;实例被new出来了&quot;);\n    &#125;\n    public static Singleton7 getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            synchronized (Singleton7.class) &#123;\n                if (instance &#x3D;&#x3D; null) &#123;\n                    instance &#x3D; new Singleton7();\n                &#125;\n            &#125;\n        &#125;\n        return instance;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>该方式是最完善的方式，面试的时候被问起直接上这种方式！</strong></p>\n<h2 id=\"四、单例模式的使用场景\"><a href=\"#四、单例模式的使用场景\" class=\"headerlink\" title=\"四、单例模式的使用场景\"></a>四、单例模式的使用场景</h2><ul>\n<li>需要频繁的进行创建和销毁的对象；</li>\n<li>创建对象时耗时过多或耗费资源过多，但又经常用到的对象；</li>\n<li>工具类对象；</li>\n<li>频繁访问数据库或文件的对象。</li>\n</ul>\n<p>优点：该类只存在一个对象，节省了系统资源（省去了对象的频繁创建与销毁），提高了系统性能。</p>\n<p>缺点：当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new，可能会给其他开发人员造成困扰，特别是看不到源码的时候。例如本文中要创建一个单例类的实例时，你要知道getInstance（）这个函数名。</p>\n","text":"单例模式一、什么是单例模式 单例类只能有一个实例 必须自行创建自己的唯一实例 向所有其他对象提供这一实例 二、单例模式的分类饿汉式：在类加载时候就创建单例（不管是否需要使用，都会先创建） 懒汉式：在需要使用实例的时候才创建 三、代码实现单例模式的核心思想： 定义私有静态对象作为该类的唯一实例obj。 私有化构造函数，保证用户不可以直接通过构造函数创建该类实例，或直接访问该类实例。 定义一个公有的getInstance()方法去获得该类的唯一单例obj。 饿汉式：方法一静态常量：将唯一实例instance设置为静态常量 public class Singleton1 &#123; private...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":1,"path":"api/categories/设计模式.json"}],"tags":[{"name":"笔记","slug":"笔记","count":11,"path":"api/tags/笔记.json"},{"name":"设计模式","slug":"设计模式","count":1,"path":"api/tags/设计模式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">单例模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">一、什么是单例模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">二、单例模式的分类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">三、代码实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">饿汉式：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%B8%80\"><span class=\"toc-text\">方法一</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%BA%8C\"><span class=\"toc-text\">方法二</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%B8%89\"><span class=\"toc-text\">方法三</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">懒汉式：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%B8%80-1\"><span class=\"toc-text\">方法一</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%BA%8C-1\"><span class=\"toc-text\">方法二</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%B8%89-1\"><span class=\"toc-text\">方法三</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%9B%9B\"><span class=\"toc-text\">方法四</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">四、单例模式的使用场景</span></a></li></ol></li></ol>","author":{"name":"Cao Wei","slug":"blog-author","avatar":"https://uploadfiles.nowcoder.com/images/20210823/575528905_1629692577639/4B05D951868901CDA3382C7B70543CD5","link":"/","description":"Code makes world better","socials":{"github":"https://github.com/wavecao","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Java多线程知识（未完待续）","uid":"b045ec127f1b9010d29cd174aab9b9b9","slug":"多线程","date":"2020-08-05T08:41:00.000Z","updated":"2020-08-07T09:06:42.000Z","comments":true,"path":"api/articles/多线程.json","keywords":null,"cover":null,"text":"Java多线程知识第一篇：基础篇第一章：进程与线程的基本概念1.1 线程和进程的一些概念进程的提出：由于批处理操作系统的指令运行方式仍然是串行的，内存中始终只有一个程序在运行，后面的程序需要等待前面的程序执行完成后才能开始执行，而前面的程序有时会由于I/O操作、网络等原因阻塞，所以批处理操作效率也不高。 进程的概念：进程就是应用程序在内存中分配的空间，也就是正在运行的程序，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态。 上下文切换：CPU为每个进程分配一个时间段，称作它的时间片。如果在时间片结束时进程还在运行，则暂停这个进程的运行，并且CPU分配给另一个进程。 当进程暂停时，它...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[{"name":"并发编程","slug":"并发编程","count":1,"path":"api/categories/并发编程.json"}],"tags":[{"name":"笔记","slug":"笔记","count":11,"path":"api/tags/笔记.json"},{"name":"并发编程","slug":"并发编程","count":1,"path":"api/tags/并发编程.json"}],"author":{"name":"Cao Wei","slug":"blog-author","avatar":"https://uploadfiles.nowcoder.com/images/20210823/575528905_1629692577639/4B05D951868901CDA3382C7B70543CD5","link":"/","description":"Code makes world better","socials":{"github":"https://github.com/wavecao","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"顺序队列和循环队列","uid":"bc120f0c5b799be5c628de13faac0671","slug":"普通队列和循环队列的Java实现","date":"2020-03-23T08:41:00.000Z","updated":"2020-07-01T01:48:14.000Z","comments":true,"path":"api/articles/普通队列和循环队列的Java实现.json","keywords":null,"cover":"http://image.cheerway.fun/blog/20200304/NJXBiQVEA48R.png?imageslim","text":"什么是队列对于数组来说，我们可以通过下标值拿到每一个具体的元素。但是有些时候我们需要一种限制存取顺序的数据结构，此时队列和栈便派上了用场。 队列与栈的不同之处在于，队列是先进先出（FIFO）而栈是后入先出（LIFO），其实队列二字“名副其实”，我们可以将其理解为日常生活中的排队：当我们在超市收银台结账时，肯定是排在前面的顾客先结账，然后依次是后面的顾客结账（不考虑某些人的插队行为）。 如上图所示，队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。 删除（delete）操作也被称为出队（dequeue)。 你只能移除第一个元素。...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"算法","slug":"算法","count":2,"path":"api/categories/算法.json"}],"tags":[{"name":"笔记","slug":"笔记","count":11,"path":"api/tags/笔记.json"},{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"}],"author":{"name":"Cao Wei","slug":"blog-author","avatar":"https://uploadfiles.nowcoder.com/images/20210823/575528905_1629692577639/4B05D951868901CDA3382C7B70543CD5","link":"/","description":"Code makes world better","socials":{"github":"https://github.com/wavecao","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}