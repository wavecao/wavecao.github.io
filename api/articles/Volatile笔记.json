{"title":"Volatile笔记","uid":"bba89471be59517c19dfa618326fae4f","slug":"Volatile笔记","date":"2020-08-19T03:14:00.000Z","updated":"2020-08-19T03:15:12.000Z","comments":true,"path":"api/articles/Volatile笔记.json","keywords":null,"cover":[],"content":"<h2 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1. 概念\"></a>1. 概念</h2><p>volatile 是 Java 中的关键字，是一个变量修饰符，用来修饰会被不同线程访问和修改的变量。</p>\n<hr>\n<h2 id=\"2-内存模型的3个特性\"><a href=\"#2-内存模型的3个特性\" class=\"headerlink\" title=\"2. 内存模型的3个特性\"></a>2. 内存模型的3个特性</h2><h3 id=\"2-1-可见性\"><a href=\"#2-1-可见性\" class=\"headerlink\" title=\"2.1 可见性\"></a>2.1 可见性</h3><p>可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</p>\n<p><strong>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的</strong>。也就是一个线程修改的结果。另一个线程马上就能看到。</p>\n<p>在 Java 中 volatile、synchronized 和 final 都可以实现可见性。</p>\n<h3 id=\"2-2-原子性\"><a href=\"#2-2-原子性\" class=\"headerlink\" title=\"2.2 原子性\"></a>2.2 原子性</h3><p>原子性指的是某个线程正在执行某个操作时，中间不可以被加塞或分割，要么整体成功，要么整体失败。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作是原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。Java 的 concurrent 包下提供了一些原子类，AtomicInteger、AtomicLong、AtomicReference等。</p>\n<p>在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。</p>\n<h3 id=\"2-3-有序性\"><a href=\"#2-3-有序性\" class=\"headerlink\" title=\"2.3 有序性\"></a>2.3 有序性</h3><p>Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作“这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。</p>\n<hr>\n<h2 id=\"3-volatile-是-Java-虚拟机提供的轻量级的同步机制\"><a href=\"#3-volatile-是-Java-虚拟机提供的轻量级的同步机制\" class=\"headerlink\" title=\"3. volatile 是 Java 虚拟机提供的轻量级的同步机制\"></a>3. volatile 是 Java 虚拟机提供的轻量级的同步机制</h2><ul>\n<li>保证可见性</li>\n<li><strong>不保证原子性</strong></li>\n<li>禁止指令重排（保证有序性）</li>\n</ul>\n<h3 id=\"3-1-空说无凭，代码验证\"><a href=\"#3-1-空说无凭，代码验证\" class=\"headerlink\" title=\"3.1 空说无凭，代码验证\"></a>3.1 空说无凭，代码验证</h3><h4 id=\"3-1-1-可见性验证\"><a href=\"#3-1-1-可见性验证\" class=\"headerlink\" title=\"3.1.1 可见性验证\"></a>3.1.1 可见性验证</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class MyData &#123;\n    int number &#x3D; 0;\n    public void add() &#123;\n        this.number &#x3D; number + 1;\n    &#125;\n&#125;\n\n   &#x2F;&#x2F; 启动两个线程，一个work线程，一个main线程，work线程修改number值后，查看main线程的number\n   private static void testVolatile() &#123;\n        MyData myData &#x3D; new MyData();\n\n        new Thread(() -&gt; &#123;\n            System.out.println(Thread.currentThread().getName()+&quot;\\t come in&quot;);\n            try &#123;\n                TimeUnit.SECONDS.sleep(2);\n                myData.add();\n                System.out.println(Thread.currentThread().getName()+&quot;\\t update number value :&quot;+myData.number);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;, &quot;workThread&quot;).start();\n\n        &#x2F;&#x2F;第2个线程，main线程\n        while (myData.number &#x3D;&#x3D; 0)&#123;\n            &#x2F;&#x2F;main线程还在找0\n        &#125;\n        System.out.println(Thread.currentThread().getName()+&quot;\\t mission is over&quot;);      \n        System.out.println(Thread.currentThread().getName()+&quot;\\t mission is over，main get number is:&quot;+myData.number);\n    &#125;\n&#125;Copy to clipboardErrorCopied</code></pre>\n\n<p>运行 <code>testVolatile()</code> 方法，输出如下，会发现在 main 线程死循环，说明 main 线程的值一直是 0</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">workThread     execute\nworkThread     update number value :1Copy to clipboardErrorCopied</code></pre>\n\n<p>修改 <code>volatile int number = 0</code>,，在 number 前加关键字 volatile,重新运行，main 线程获取结果为 1</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">workThread     execute\nworkThread     update number value :1\nmain     execute over，main get number is:1Copy to clipboardErrorCopied</code></pre>\n\n<h4 id=\"3-1-2-不保证原子性验证\"><a href=\"#3-1-2-不保证原子性验证\" class=\"headerlink\" title=\"3.1.2 不保证原子性验证\"></a>3.1.2 不保证原子性验证</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class MyData &#123;\n    volatile int number &#x3D; 0;\n    public void add() &#123;\n        this.number &#x3D; number + 1;\n    &#125;\n&#125;\n\nprivate static void testAtomic() throws InterruptedException &#123;\n  MyData myData &#x3D; new MyData();\n\n  for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n    new Thread(() -&gt;&#123;\n      for (int j &#x3D; 0; j &lt; 1000; j++) &#123;\n        myData.addPlusPlus();\n      &#125;\n    &#125;,&quot;addPlusThread:&quot;+ i).start();\n  &#125;\n\n\n  &#x2F;&#x2F;等待上边20个线程结束后(预计5秒肯定结束了)，在main线程中获取最后的number\n  TimeUnit.SECONDS.sleep(5);\n  while (Thread.activeCount() &gt; 2)&#123;\n    Thread.yield();\n  &#125;\n  System.out.println(&quot;final value：&quot;+myData.number);\n&#125;Copy to clipboardErrorCopied</code></pre>\n\n<p>运行 <code>testAtomic</code> 发现最后的输出值，并不一定是期望的值 10000，往往是比 10000 小的数值。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final value：9856Copy to clipboardErrorCopied</code></pre>\n\n<p>为什么会这样呢，因为 <code>i++</code> 在转化为字节码指令的时候是4条指令</p>\n<ul>\n<li><code>getfield</code> 获取原始值</li>\n<li><code>iconst_1</code> 将值入栈</li>\n<li><code>iadd</code> 进行加 1 操作</li>\n<li><code>putfield</code> 把 <code>iadd</code> 后的操作写回主内存</li>\n</ul>\n<p>这样在运行时候就会存在多线程竞争问题，可能会出现了丢失写值的情况。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/00831rSTly1gd0pb766vkj31hw0lyjvm.jpg\" alt=\"img\"></p>\n<p>如何解决原子性问题呢？</p>\n<p>加 <code>synchronized</code> 或者直接使用 <code>Automic</code> 原子类。</p>\n<h4 id=\"3-1-3-禁止指令重排验证\"><a href=\"#3-1-3-禁止指令重排验证\" class=\"headerlink\" title=\"3.1.3 禁止指令重排验证\"></a>3.1.3 禁止指令重排验证</h4><p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排，一般分为以下 3 种</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/00831rSTly1gcrgrycnj0j31bs04k74y.jpg\" alt=\"img\"></p>\n<p>处理器在进行重排序时必须要考虑指令之间的<strong>数据依赖性</strong>，我们叫做 <code>as-if-serial</code> 语义</p>\n<p>单线程环境里确保程序最终执行结果和代码顺序执行的结果一致；但是多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</p>\n<p>我们往往用下面的代码验证 volatile 禁止指令重排，如果多线程环境下，最后的输出结果不一定是我们想象到的 ，这时就要把两个变量都设置为 volatile。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ReSortSeqDemo &#123;\n\n    int a &#x3D; 0;\n    boolean flag &#x3D; false;\n\n    public void mehtod1()&#123;\n        a &#x3D; 1;\n        flag &#x3D; true;\n    &#125;\n\n    public void method2()&#123;\n        if(flag)&#123;\n            a &#x3D; a +1;\n            System.out.println(&quot;reorder value: &quot;+a);\n        &#125;\n    &#125;\n&#125;Copy to clipboardErrorCopied</code></pre>\n\n<p><code>volatile</code> 实现禁止指令重排优化，从而避免了多线程环境下程序出现乱序执行的现象。</p>\n<p>还有一个我们最常见的多线程环境中 <code>DCL(double-checked locking)</code> 版本的单例模式中，就是使用了 volatile 禁止指令重排的特性。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton &#123;\n\n    private static volatile Singleton instance;\n\n    private Singleton()&#123;&#125;\n    &#x2F;&#x2F; DCL\n    public static Singleton getInstance()&#123;\n        if(instance &#x3D;&#x3D;null)&#123;   &#x2F;&#x2F;第一次检查\n            synchronized (Singleton.class)&#123;\n                if(instance &#x3D;&#x3D; null)&#123;   &#x2F;&#x2F;第二次检查\n                    instance &#x3D; new Singleton();\n                &#125;\n            &#125;\n        &#125;\n        return instance;\n    &#125;\n&#125;Copy to clipboardErrorCopied</code></pre>\n\n<p>因为有指令重排序的存在，双端检索机制也不一定是线程安全的。</p>\n<p>why ?</p>\n<p>Because: <code>instance = new Singleton();</code> 初始化对象的过程其实并不是一个原子的操作，它会分为三部分执行，</p>\n<ol>\n<li>给 instance 分配内存</li>\n<li>调用 instance 的构造函数来初始化对象</li>\n<li>将 instance 对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</li>\n</ol>\n<p>步骤 2 和 3 不存在数据依赖关系，如果虚拟机存在指令重排序优化，则步骤 2和 3 的顺序是无法确定的。如果A线程率先进入同步代码块并先执行了 3 而没有执行 2，此时因为 instance 已经非 null。这时候线程 B 在第一次检查的时候，会发现 instance 已经是 非null 了，就将其返回使用，但是此时 instance 实际上还未初始化，自然就会出错。所以我们要限制实例对象的指令重排，用 volatile 修饰（JDK 5 之前使用了 volatile 的双检锁是有问题的）。</p>\n<hr>\n<h2 id=\"4-原理\"><a href=\"#4-原理\" class=\"headerlink\" title=\"4. 原理\"></a>4. 原理</h2><p>volatile 可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在 JVM 底层是基于内存屏障实现的。</p>\n<ul>\n<li>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有多个CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中</li>\n<li>而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步，所以就不会有可见性问题<ul>\n<li>对 volatile 变量进行写操作时，会在写操作后加一条 store 屏障指令，将工作内存中的共享变量刷新回主内存；</li>\n<li>对 volatile 变量进行读操作时，会在写操作后加一条 load 屏障指令，从主内存中读取共享变量；</li>\n</ul>\n</li>\n</ul>\n<p>通过 hsdis 工具获取 JIT 编译器生成的汇编指令来看看对 volatile 进行写操作CPU会做什么事情，还是用上边的单例模式，可以看到</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/00831rSTly1gdhgvi4pz9j30xf0tgjuy.jpg\" alt=\"img\"></p>\n<p>（PS：具体的汇编指令对我这个 Javaer 太南了，但是 JVM 字节码我们可以认识，<code>putstatic</code> 的含义是给一个静态变量设置值，那这里的 <code>putstatic instance</code> ,而且是第 17 行代码，更加确定是给 instance 赋值了。果然像各种资料里说的，找到了 <code>lock add1</code> 据说还得翻阅。这里可以看下这两篇 <a href=\"https://www.jianshu.com/p/6ab7c3db13c3\">https://www.jianshu.com/p/6ab7c3db13c3</a> 、 <a href=\"https://www.cnblogs.com/xrq730/p/7048693.html\">https://www.cnblogs.com/xrq730/p/7048693.html</a> ）</p>\n<p>有 volatile 修饰的共享变量进行写操作时会多出第二行汇编代码，该句代码的意思是<strong>对原值加零</strong>，其中相加指令addl前有 <strong>lock</strong> 修饰。通过查IA-32架构软件开发者手册可知，lock前缀的指令在多核处理器下会引发两件事情：</p>\n<ul>\n<li>将当前处理器缓存行的数据写回到系统内存</li>\n<li>这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效</li>\n</ul>\n<p><strong>正是 lock 实现了 volatile 的「防止指令重排」「内存可见」的特性</strong></p>\n<hr>\n<h2 id=\"5-使用场景\"><a href=\"#5-使用场景\" class=\"headerlink\" title=\"5. 使用场景\"></a>5. 使用场景</h2><p>您只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：</p>\n<ul>\n<li>对变量的写操作不依赖于当前值</li>\n<li>该变量没有包含在具有其他变量的不变式中</li>\n</ul>\n<p>其实就是在需要保证原子性的场景，不要使用 volatile。</p>\n<hr>\n<h2 id=\"6-volatile-性能\"><a href=\"#6-volatile-性能\" class=\"headerlink\" title=\"6. volatile 性能\"></a>6. volatile 性能</h2><p>volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p>\n<p>引用《正确使用 volaitle 变量》一文中的话：</p>\n<p>很难做出准确、全面的评价，例如 “X 总是比 Y 快”，尤其是对 JVM 内在的操作而言。（例如，某些情况下 JVM 也许能够完全删除锁机制，这使得我们难以抽象地比较 <code>volatile</code> 和 <code>synchronized</code> 的开销。）就是说，在目前大多数的处理器架构上，volatile 读操作开销非常低 —— 几乎和非 volatile 读操作一样。而 volatile 写操作的开销要比非 volatile 写操作多很多，因为要保证可见性需要实现内存界定（Memory Fence），即便如此，volatile 的总开销仍然要比锁获取低。</p>\n<p>volatile 操作不会像锁一样造成阻塞，因此，在能够安全使用 volatile 的情况下，volatile 可以提供一些优于锁的可伸缩特性。如果读操作的次数要远远超过写操作，与锁相比，volatile 变量通常能够减少同步的性能开销。</p>\n","feature":true,"text":"1. 概念volatile 是 Java 中的关键字，是一个变量修饰符，用来修饰会被不同线程访问和修改的变量。 2. 内存模型的3个特性2.1 可见性可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。 可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。 在 Java 中 volatile、synchronized 和 final 都可以实现可见性。 2.2 原...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"笔记","slug":"笔记","count":1,"path":"api/categories/笔记.json"}],"tags":[{"name":"笔记","slug":"笔记","count":11,"path":"api/tags/笔记.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1. 概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%843%E4%B8%AA%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">2. 内存模型的3个特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E5%8F%AF%E8%A7%81%E6%80%A7\"><span class=\"toc-text\">2.1 可见性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E5%8E%9F%E5%AD%90%E6%80%A7\"><span class=\"toc-text\">2.2 原子性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E6%9C%89%E5%BA%8F%E6%80%A7\"><span class=\"toc-text\">2.3 有序性</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-volatile-%E6%98%AF-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8F%90%E4%BE%9B%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">3. volatile 是 Java 虚拟机提供的轻量级的同步机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E7%A9%BA%E8%AF%B4%E6%97%A0%E5%87%AD%EF%BC%8C%E4%BB%A3%E7%A0%81%E9%AA%8C%E8%AF%81\"><span class=\"toc-text\">3.1 空说无凭，代码验证</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-1-%E5%8F%AF%E8%A7%81%E6%80%A7%E9%AA%8C%E8%AF%81\"><span class=\"toc-text\">3.1.1 可见性验证</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-2-%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E9%AA%8C%E8%AF%81\"><span class=\"toc-text\">3.1.2 不保证原子性验证</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-3-%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E9%AA%8C%E8%AF%81\"><span class=\"toc-text\">3.1.3 禁止指令重排验证</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">4. 原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">5. 使用场景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-volatile-%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">6. volatile 性能</span></a></li></ol>","author":{"name":"Cao Wei","slug":"blog-author","avatar":"https://uploadfiles.nowcoder.com/images/20210823/575528905_1629692577639/4B05D951868901CDA3382C7B70543CD5","link":"/","description":"Code makes world better","socials":{"github":"https://github.com/wavecao","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Linux学习笔记——一篇入门Linux","uid":"81b01b0fe0649b3c1227863a4d704276","slug":"Linux学习笔记","date":"2020-08-20T01:47:00.000Z","updated":"2020-08-20T00:57:14.000Z","comments":true,"path":"api/articles/Linux学习笔记.json","keywords":null,"cover":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1597895038826&di=423dbc0befbefd0d55195ee12e7ff13e&imgtype=0&src=http%3A%2F%2Fimg.cnitedu.cn%2Fuploads%2Fallimg%2F1910%2Fwsh1012002.jpg","text":"Linux学习笔记1. Linux简介简介Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。 Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。 Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 发行版Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。 目前市...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"Linux","slug":"Linux","count":1,"path":"api/categories/Linux.json"}],"tags":[{"name":"笔记","slug":"笔记","count":11,"path":"api/tags/笔记.json"},{"name":"Linux","slug":"Linux","count":1,"path":"api/tags/Linux.json"}],"author":{"name":"Cao Wei","slug":"blog-author","avatar":"https://uploadfiles.nowcoder.com/images/20210823/575528905_1629692577639/4B05D951868901CDA3382C7B70543CD5","link":"/","description":"Code makes world better","socials":{"github":"https://github.com/wavecao","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Java多线程知识（未完待续）","uid":"b045ec127f1b9010d29cd174aab9b9b9","slug":"多线程","date":"2020-08-05T08:41:00.000Z","updated":"2020-08-07T09:06:42.000Z","comments":true,"path":"api/articles/多线程.json","keywords":null,"cover":null,"text":"Java多线程知识第一篇：基础篇第一章：进程与线程的基本概念1.1 线程和进程的一些概念进程的提出：由于批处理操作系统的指令运行方式仍然是串行的，内存中始终只有一个程序在运行，后面的程序需要等待前面的程序执行完成后才能开始执行，而前面的程序有时会由于I/O操作、网络等原因阻塞，所以批处理操作效率也不高。 进程的概念：进程就是应用程序在内存中分配的空间，也就是正在运行的程序，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态。 上下文切换：CPU为每个进程分配一个时间段，称作它的时间片。如果在时间片结束时进程还在运行，则暂停这个进程的运行，并且CPU分配给另一个进程。 当进程暂停时，它...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[{"name":"并发编程","slug":"并发编程","count":1,"path":"api/categories/并发编程.json"}],"tags":[{"name":"笔记","slug":"笔记","count":11,"path":"api/tags/笔记.json"},{"name":"并发编程","slug":"并发编程","count":1,"path":"api/tags/并发编程.json"}],"author":{"name":"Cao Wei","slug":"blog-author","avatar":"https://uploadfiles.nowcoder.com/images/20210823/575528905_1629692577639/4B05D951868901CDA3382C7B70543CD5","link":"/","description":"Code makes world better","socials":{"github":"https://github.com/wavecao","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}