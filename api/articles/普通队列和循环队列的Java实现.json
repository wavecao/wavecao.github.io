{"title":"顺序队列和循环队列","uid":"bc120f0c5b799be5c628de13faac0671","slug":"普通队列和循环队列的Java实现","date":"2020-03-23T08:41:00.000Z","updated":"2020-07-01T01:48:14.000Z","comments":true,"path":"api/articles/普通队列和循环队列的Java实现.json","keywords":null,"cover":"http://image.cheerway.fun/blog/20200304/NJXBiQVEA48R.png?imageslim","content":"<h3 id=\"什么是队列\"><a href=\"#什么是队列\" class=\"headerlink\" title=\"什么是队列\"></a>什么是队列</h3><p>对于数组来说，我们可以通过下标值拿到每一个具体的元素。但是有些时候我们需要一种限制存取顺序的数据结构，此时队列和栈便派上了用场。</p>\n<p>队列与栈的不同之处在于，队列是先进先出（FIFO）而栈是后入先出（LIFO），其实<code>队列</code>二字“名副其实”，我们可以将其理解为日常生活中的排队：当我们在超市收银台结账时，肯定是排在前面的顾客先结账，然后依次是后面的顾客结账（不考虑某些人的插队行为）。</p>\n<p><img src=\"http://image.cheerway.fun/Snipaste_2020-03-23_15-49-30.png\" alt=\"mark\"></p>\n<p>如上图所示，队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在<code>队列的末尾</code>。 删除（delete）操作也被称为出队（dequeue)。 你只能移除<code>第一个元素</code>。</p>\n<h3 id=\"顺序队列\"><a href=\"#顺序队列\" class=\"headerlink\" title=\"顺序队列\"></a>顺序队列</h3><p>顺序队列可以基于动态数组和指向头部的指针的方式实现的，是连续的一块内存空间。其结构如下图：</p>\n<img src=\"http://image.cheerway.fun/blog/20200323/PfkWFmuOECIu.jpg?imageslim\" alt=\"mark\" style=\"zoom:50%;\" />\n\n<p>按照上述，其实现也十分简单，下面给出一种实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyQueue &#123;\n    &#x2F;&#x2F;存储数据\n    private List&lt;Integer&gt; data;\n    &#x2F;&#x2F;指向队列头部数据的指针\n    private int p_start;\n\n    public MyQueue() &#123;\n        this.data &#x3D; data &#x3D; new ArrayList&lt;Integer&gt;();\n        this.p_start &#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F;数据入列\n    public Boolean enQueue(int x)&#123;\n        data.add(x);\n        return true;\n    &#125;\n\n    &#x2F;&#x2F;数据出列\n    public Boolean deQueue()&#123;\n        if (isEmpty())&#123;\n            return false;\n        &#125;\n        p_start++;\n        return true;\n    &#125;\n\n    &#x2F;&#x2F;获取队列头的元素\n    public int getFront()&#123;\n        return data.get(p_start);\n    &#125;\n\n    &#x2F;&#x2F;判断是否为空\n    public Boolean isEmpty()&#123;\n        return p_start &gt;&#x3D; data.size();\n    &#125;\n\n    public static void main(String[] args) &#123;\n        MyQueue myQueue &#x3D; new MyQueue();\n        myQueue.enQueue(1);\n        myQueue.enQueue(2);\n        myQueue.enQueue(3);\n        myQueue.enQueue(4);\n        System.out.println(myQueue.getFront());\n        myQueue.deQueue();\n        System.out.println(myQueue.getFront());\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"顺序队列的缺点\"><a href=\"#顺序队列的缺点\" class=\"headerlink\" title=\"顺序队列的缺点\"></a>顺序队列的缺点</h3><p>顺序队列的实现确实很简单，但是随着我们对一部分数据进行出队操作后，头部指针会渐渐后移，而头部指针前面的空间虽然已经被释放，但是它既不能被回收也不能被再次利用，造成了很大的空间浪费，我们当然可以每次队列满了以后将数据总体前移（如下图所示），这样虽然保证了空间不会被浪费，但是时间复杂度从O(1)变成了O(n)，也是非常大的性能开销。</p>\n<img src=\"https://upload-images.jianshu.io/upload_images/2005932-580777cb33fcaf68.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1142/format/webp\" style=\"zoom:50%;\" />\n\n<h3 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h3><p>上述通过数组来实现的队列，我们虽然进行了优化，但是当有空间无法利用时时，还是会进行一次数据搬移，性能也会收到影响，能否避免数据呢？答案是肯定的，看一下循环队列的解决思路。</p>\n<p>循环队列就相当于一个圆环，数组可以想象成一条直线，我们把这条直线掰成一个圆环，就是循环队列，为了更形象的表示，可以看下图所示：</p>\n<p><img src=\"http://image.cheerway.fun/blog/20200701/vavymwwzDzOe.jpg?imageslim\" alt=\"mark\"></p>\n<p>循环队列中，我们需要两个指针，即head和tail分别指向队列的头和尾，当队列初始化时，head和tail都指向索引为0的位置。如果有数据入队，tail则后移一次，如果有数据出队，head则后移一次。</p>\n<p>但是上述的过程会出现一系列问题：</p>\n<ul>\n<li>如果数组的大小为4，当tail指向3时，怎样让下一次入队时tail指向0（假设0位置可以插入）而不是指向4（指向4就造成数组下标越界了）？</li>\n<li>当队列空或者满时，都存在head=tail，如何判断队列到底是空还是满？</li>\n</ul>\n<p>下面我们逐个解决</p>\n<ol>\n<li><p>关于指针越界的问题其实很简单，我们只需要每次在对tail或者head加1时进行一次取余操作，即</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">(head + 1) % size;</code></pre></li>\n<li><p>关于判断队列空和满状态的问题，我的思路是：舍弃一个存储空间。也就是说如果tail的下一个是head，那么现在tail指向的空间就不再存储数据。如果是队列不断进行出队操作，head渐渐“追上”tail时，会出现head=tail的情况，此时队列为空。</p>\n</li>\n</ol>\n<p>总结一下：舍弃队列的最后一个存储空间，那么队列为空的标志是<code>(tail + 1) % size = head</code>，队列为满的标志是<code>head = tail</code>。</p>\n<p>为了满足用户的需求，在实现时我们必须保证用户请求的空间数，因此具体到代码实现上，我们初始化队列时就初始化一个比用户申请空间大1的数组。下面给出一种代码实现：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyCircularQueue &#123;\n\n    private int[] data;\n    private int head;\n    private int tail;\n    private int size;\n\n    &#x2F;**\n     * Initialize your data structure here. Set the size of the queue to be k.\n     *&#x2F;\n    public MyCircularQueue(int k) &#123;\n        &#x2F;&#x2F;初始化一个比用户要求大1的数组\n        size &#x3D; k+1;\n        data &#x3D; new int[size];\n        head &#x3D; 0;\n        tail &#x3D; 0;\n    &#125;\n\n    &#x2F;**\n     * Insert an element into the circular queue. Return true if the operation is successful.\n     *&#x2F;\n    public boolean enQueue(int value) &#123;\n        if (isFull()) &#123;\n            return false;\n        &#125;\n        data[tail] &#x3D; value;\n        tail &#x3D; (tail + 1) % size;\n        return true;\n    &#125;\n\n    &#x2F;**\n     * Delete an element from the circular queue. Return true if the operation is successful.\n     *&#x2F;\n    public boolean deQueue() &#123;\n        if (isEmpty())&#123;\n            return false;\n        &#125;\n        head &#x3D; (head + 1) % size;\n        return true;\n    &#125;\n\n    &#x2F;**\n     * Get the front item from the queue.\n     *&#x2F;\n    public int Front() &#123;\n        if (isEmpty())&#123;\n            return -1;\n        &#125;\n        return data[head];\n    &#125;\n\n    &#x2F;**\n     * Get the last item from the queue.\n     *&#x2F;\n    public int Rear() &#123;\n        if (isEmpty())&#123;\n            return -1;\n        &#125;\n        &#x2F;&#x2F;之所以要加上size是因为此处tail可能是0\n        return data[(tail - 1 + size) % size];\n    &#125;\n\n    &#x2F;**\n     * Checks whether the circular queue is empty or not.\n     *&#x2F;\n    public boolean isEmpty() &#123;\n        return head &#x3D;&#x3D; tail;\n    &#125;\n\n    &#x2F;**\n     * Checks whether the circular queue is full or not.\n     * 如果仅仅使用tail &#x3D;&#x3D; head来判断队列是否满，则无法判断到底是空还是满\n     * 因此要牺牲最后一个存储单元。即如果tail的下一个是head，就认为满了\n     *&#x2F;\n    public boolean isFull() &#123;\n        return (tail + 1) % size &#x3D;&#x3D; head;\n    &#125;\n\n&#125;\n</code></pre>\n\n<h3 id=\"队列的其他形式\"><a href=\"#队列的其他形式\" class=\"headerlink\" title=\"队列的其他形式\"></a>队列的其他形式</h3><p>队列其实还有链式队列，无界队列，阻塞队列、并发队列等等，我们以后再聊！</p>\n","text":"什么是队列对于数组来说，我们可以通过下标值拿到每一个具体的元素。但是有些时候我们需要一种限制存取顺序的数据结构，此时队列和栈便派上了用场。 队列与栈的不同之处在于，队列是先进先出（FIFO）而栈是后入先出（LIFO），其实队列二字“名副其实”，我们可以将其理解为日常生活中的排队：当我们在超市收银台结账时，肯定是排在前面的顾客先结账，然后依次是后面的顾客结账（不考虑某些人的插队行为）。 如上图所示，队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。 删除（delete）操作也被称为出队（dequeue)。 你只能移除第一个元素。...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"算法","slug":"算法","count":2,"path":"api/categories/算法.json"}],"tags":[{"name":"笔记","slug":"笔记","count":11,"path":"api/tags/笔记.json"},{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">什么是队列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97\"><span class=\"toc-text\">顺序队列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E7%9A%84%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">顺序队列的缺点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">循环队列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%98%9F%E5%88%97%E7%9A%84%E5%85%B6%E4%BB%96%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">队列的其他形式</span></a></li></ol>","author":{"name":"Cao Wei","slug":"blog-author","avatar":"https://uploadfiles.nowcoder.com/images/20210823/575528905_1629692577639/4B05D951868901CDA3382C7B70543CD5","link":"/","description":"Code makes world better","socials":{"github":"https://github.com/wavecao","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"单例模式详解","uid":"a38aadce42dddbcde7f41fcb5e12b8a9","slug":"单例模式","date":"2020-07-28T09:02:00.000Z","updated":"2020-07-28T09:03:02.000Z","comments":true,"path":"api/articles/单例模式.json","keywords":null,"cover":null,"text":"单例模式一、什么是单例模式 单例类只能有一个实例 必须自行创建自己的唯一实例 向所有其他对象提供这一实例 二、单例模式的分类饿汉式：在类加载时候就创建单例（不管是否需要使用，都会先创建） 懒汉式：在需要使用实例的时候才创建 三、代码实现单例模式的核心思想： 定义私有静态对象作为该类的唯一实例obj。 私有化构造函数，保证用户不可以直接通过构造函数创建该类实例，或直接访问该类实例。 定义一个公有的getInstance()方法去获得该类的唯一单例obj。 饿汉式：方法一静态常量：将唯一实例instance设置为静态常量 public class Singleton1 &#123; private...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":1,"path":"api/categories/设计模式.json"}],"tags":[{"name":"笔记","slug":"笔记","count":11,"path":"api/tags/笔记.json"},{"name":"设计模式","slug":"设计模式","count":1,"path":"api/tags/设计模式.json"}],"author":{"name":"Cao Wei","slug":"blog-author","avatar":"https://uploadfiles.nowcoder.com/images/20210823/575528905_1629692577639/4B05D951868901CDA3382C7B70543CD5","link":"/","description":"Code makes world better","socials":{"github":"https://github.com/wavecao","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Vue组件基础","uid":"377b436afa644e00cf7f3b27b55ec3f4","slug":"Vue组件基础","date":"2020-03-13T09:34:00.000Z","updated":"2020-09-16T13:44:38.000Z","comments":true,"path":"api/articles/Vue组件基础.json","keywords":null,"cover":"http://image.cheerway.fun/blog/20200304/NJXBiQVEA48R.png?imageslim","text":"Vue组件基础Vue的组件化思想组件化是Vue中很重要的思想： 它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用 任何的应用都会被抽象成一颗组件树 组件化思想的应用： 有了组件化的思想，我们在之后的开发中就要充分的利用它。 尽可能的将页面拆分成一个个小的、可复用的组件。 这样让我们的代码更加方便组织和管理，并且扩展性也更强。 注册组件全局注册 Vue.component(‘组件名称’, { }) 第1个参数是标签名称，第2个参数是一个选项对象 全局组件注册后，任何vue实例都可以用 &lt;div id&#x3D;&quot;example&quot;&gt; &lt...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"16 mins."},"categories":[{"name":"Vue","slug":"Vue","count":2,"path":"api/categories/Vue.json"}],"tags":[{"name":"笔记","slug":"笔记","count":11,"path":"api/tags/笔记.json"},{"name":"Vue","slug":"Vue","count":2,"path":"api/tags/Vue.json"}],"author":{"name":"Cao Wei","slug":"blog-author","avatar":"https://uploadfiles.nowcoder.com/images/20210823/575528905_1629692577639/4B05D951868901CDA3382C7B70543CD5","link":"/","description":"Code makes world better","socials":{"github":"https://github.com/wavecao","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}