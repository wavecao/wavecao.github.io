{"title":"Java多线程知识（未完待续）","uid":"b045ec127f1b9010d29cd174aab9b9b9","slug":"多线程","date":"2020-08-05T08:41:00.000Z","updated":"2020-08-07T09:06:42.000Z","comments":true,"path":"api/articles/多线程.json","keywords":null,"cover":null,"content":"<h1 id=\"Java多线程知识\"><a href=\"#Java多线程知识\" class=\"headerlink\" title=\"Java多线程知识\"></a>Java多线程知识</h1><h2 id=\"第一篇：基础篇\"><a href=\"#第一篇：基础篇\" class=\"headerlink\" title=\"第一篇：基础篇\"></a>第一篇：基础篇</h2><h3 id=\"第一章：进程与线程的基本概念\"><a href=\"#第一章：进程与线程的基本概念\" class=\"headerlink\" title=\"第一章：进程与线程的基本概念\"></a>第一章：进程与线程的基本概念</h3><h4 id=\"1-1-线程和进程的一些概念\"><a href=\"#1-1-线程和进程的一些概念\" class=\"headerlink\" title=\"1.1 线程和进程的一些概念\"></a>1.1 线程和进程的一些概念</h4><p><strong>进程的提出：</strong>由于<strong>批处理操作系统的指令运行方式仍然是串行的，内存中始终只有一个程序在运行</strong>，后面的程序需要等待前面的程序执行完成后才能开始执行，而前面的程序有时会由于I/O操作、网络等原因阻塞，所以<strong>批处理操作效率也不高</strong>。</p>\n<p><strong>进程的概念：</strong>进程就是<strong>应用程序在内存中分配的空间，也就是正在运行的程序</strong>，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态。</p>\n<p><strong>上下文切换：</strong>CPU为每个进程分配一个时间段，称作它的时间片。如果在时间片结束时进程还在运行，则暂停这个进程的运行，并且CPU分配给另一个进程。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>当进程暂停时，它会保存当前进程的状态（进程标识，进程使用的资源等），在下一次切换回来时根据之前保存的状态进行恢复，接着继续执行。</p></blockquote>\n<p><strong>进程让操作系统的并发成为了可能！</strong></p>\n<p><strong>线程的提出：</strong>虽然进程的出现，使得操作系统的性能大大提升，但是随着时间的推移，人们并不满足一个进程在一段时间只能做一件事情，如果一个进程有多个子任务时，只能逐个得执行这些子任务，很影响效率。</p>\n<p><strong>线程的概念：</strong>让一个线程执行一个子任务，这样一个进程就包含了多个线程，每个线程负责一个单独的子任务。</p>\n<p><strong>进程让操作系统的并发性成为了可能，而线程让进程的内部并发成为了可能。</strong></p>\n<p>使用多线程的<strong>好处：</strong></p>\n<ul>\n<li>进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，我们需要使用共享资源，这些资源在线程间的通信比较容易。</li>\n<li>进程是重量级的，而线程是轻量级的，故多线程方式的系统开销更小。</li>\n</ul>\n<p><strong>进程和线程的区别：</strong></p>\n<p><code>二者最本质的区别就是是否单独占有内存地址空间以及其他系统资源（比如I/O）</code></p>\n<ul>\n<li>进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。</li>\n<li>进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。</li>\n<li>进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。</li>\n</ul>\n<p>另外一个重要区别是，<strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位</strong>，即CPU分配时间的单位 。</p>\n<h4 id=\"1-2-上下文切换\"><a href=\"#1-2-上下文切换\" class=\"headerlink\" title=\"1.2 上下文切换\"></a>1.2 上下文切换</h4><p>上下文切换（有时也称做进程切换或任务切换）是指 CPU 从一个进程（或线程）切换到另一个进程（或线程）。上下文是指<strong>某一时间点 CPU 寄存器和程序计数器的内容。</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>寄存器是cpu内部的少量的速度很快的闪存，通常存储和访问计算过程的中间值提高计算机程序的运行速度。</p>\n<p>程序计数器是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体实现依赖于特定的系统。</p>\n<p>举例说明 线程A - B</p>\n<p>1.先挂起线程A，将其在cpu中的状态保存在内存中。</p>\n<p>2.在内存中检索下一个线程B的上下文并将其在 CPU 的寄存器中恢复,执行B线程。</p>\n<p>3.当B执行完，根据程序计数器中指向的位置恢复线程A。</p></blockquote>\n<p>CPU通过为每个线程分配CPU时间片来实现多线程机制。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。</p>\n<p>但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p>\n<p>上下文切换通常是计算密集型的，意味着此操作会<strong>消耗大量的 CPU 时间，故线程也不是越多越好</strong>。如何减少系统中上下文切换次数，是提升多线程性能的一个重点课题。</p>\n<h3 id=\"第二章：Java多线程入门类和接口\"><a href=\"#第二章：Java多线程入门类和接口\" class=\"headerlink\" title=\"第二章：Java多线程入门类和接口\"></a>第二章：Java多线程入门类和接口</h3><h4 id=\"2-1-Thread类和Runnable接口\"><a href=\"#2-1-Thread类和Runnable接口\" class=\"headerlink\" title=\"2.1 Thread类和Runnable接口\"></a>2.1 Thread类和Runnable接口</h4><p>JDk为我们提供了Thread类和Runnable接口实现自己的线程：</p>\n<ul>\n<li>继承<code>Thread</code>类，并重写<code>run()</code>方法</li>\n<li>实现<code>Runnable</code>接口的<code>run()</code>方法</li>\n</ul>\n<h5 id=\"2-1-1-继承Thread类\"><a href=\"#2-1-1-继承Thread类\" class=\"headerlink\" title=\"2.1.1 继承Thread类\"></a>2.1.1 继承Thread类</h5><p>代码示例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    public static class MyThread extends Thread &#123;\n        @Override\n        public void run() &#123;\n            System.out.println(&quot;MyThread&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Thread myThread &#x3D; new MyThread();\n        myThread.start();\n    &#125;\n&#125;</code></pre>\n\n<p>必须要调用<code>start()</code>方法以后，线程才算启动！</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>我们调用<code>start()</code>方法之后，虚拟机会创建出一个线程，此时线程只是就绪状态，只有当前线程分配到CPU时间片以后，再调用<code>run()</code>方法，线程开始执行任务。</p>\n<p>不可以多次调用<code>start()</code> 方法，不然会报异常！</p></blockquote>\n<h5 id=\"2-1-2-实现Runnable接口\"><a href=\"#2-1-2-实现Runnable接口\" class=\"headerlink\" title=\"2.1.2 实现Runnable接口\"></a>2.1.2 实现Runnable接口</h5><p>Runnable接口是一个函数式接口：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@FunctionalInterface\npublic interface Runnable &#123;\n    public abstract void run();\n&#125;</code></pre>\n\n<p>这意味着可以使用函数式编程来简化代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    public static class MyThread implements Runnable &#123;\n        @Override\n        public void run() &#123;\n            System.out.println(&quot;MyThread&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        new MyThread().run();\n\n        &#x2F;&#x2F; Java 8 函数式编程，可以省略MyThread类\n        new Thread(() -&gt; &#123;\n            System.out.println(&quot;Java 8 匿名内部类&quot;);\n        &#125;).start();\n    &#125;\n&#125;</code></pre>\n\n<h5 id=\"2-1-3-Thread类的构造方法\"><a href=\"#2-1-3-Thread类的构造方法\" class=\"headerlink\" title=\"2.1.3 Thread类的构造方法\"></a>2.1.3 Thread类的构造方法</h5><p><code>Thread</code>类是一个<code>Runnable</code>接口的实现类，我们来看看<code>Thread</code>类的源码。</p>\n<p>查看<code>Thread</code>类的构造方法，发现其实是简单调用一个私有的<code>init</code>方法来实现初始化。<code>init</code>的方法签名：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Thread类源码 \n\n&#x2F;&#x2F; 片段1 - init方法\nprivate void init(ThreadGroup g, Runnable target, String name,\n                      long stackSize, AccessControlContext acc,\n                      boolean inheritThreadLocals)\n\n&#x2F;&#x2F; 片段2 - 构造函数调用init方法\npublic Thread(Runnable target) &#123;\n    init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);\n&#125;\n\n&#x2F;&#x2F; 片段3 - 使用在init方法里初始化AccessControlContext类型的私有属性\nthis.inheritedAccessControlContext &#x3D; \n    acc !&#x3D; null ? acc : AccessController.getContext();\n\n&#x2F;&#x2F; 片段4 - 两个对用于支持ThreadLocal的私有属性\nThreadLocal.ThreadLocalMap threadLocals &#x3D; null;\nThreadLocal.ThreadLocalMap inheritableThreadLocals &#x3D; null;</code></pre>\n\n<p>我们挨个来解释一下<code>init</code>方法的这些参数：</p>\n<ul>\n<li><p>g：线程组，指定这个线程是在哪个线程组下；</p>\n</li>\n<li><p>target：指定要执行的任务；</p>\n</li>\n<li><p>name：线程的名字，多个线程的名字是可以重复的。如果不指定名字，见片段2；</p>\n</li>\n<li><p>acc：见片段3，用于初始化私有变量<code>inheritedAccessControlContext</code>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这个变量有点神奇。它是一个私有变量，但是在<code>Thread</code>类里只有<code>init</code>方法对它进行初始化，在<code>exit</code>方法把它设为<code>null</code>。其它没有任何地方使用它。一般我们是不会使用它的，那什么时候会使用到这个变量呢？可以参考这个stackoverflow的问题：<a href=\"https://stackoverflow.com/questions/13516766/restrict-permissions-to-threads-which-execute-third-party-software\">Restrict permissions to threads which execute third party software</a>；</p></blockquote>\n</li>\n<li><p>inheritThreadLocals：可继承的<code>ThreadLocal</code>，见片段4，<code>Thread</code>类里面有两个私有属性来支持<code>ThreadLocal</code>，我们会在后面的章节介绍<code>ThreadLocal</code>的概念。</p>\n</li>\n</ul>\n<p>实际情况下，我们大多是直接调用下面两个构造方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Thread(Runnable target)\nThread(Runnable target, String name)</code></pre>\n\n<h5 id=\"2-1-4-Thread类的几个常用方法\"><a href=\"#2-1-4-Thread类的几个常用方法\" class=\"headerlink\" title=\"2.1.4 Thread类的几个常用方法\"></a>2.1.4 Thread类的几个常用方法</h5><ul>\n<li>currentThread()：静态方法，返回对当前正在执行的线程对象的引用；</li>\n<li>start()：开始执行线程的方法，java虚拟机会调用线程内的run()方法；</li>\n<li>yield()：yield在英语里有放弃的意思，同样，这里的yield()指的是当前线程愿意让出对当前处理器的占用。这里需要注意的是，就算当前线程调用了yield()方法，程序在调度的时候，也还有可能继续运行这个线程的；</li>\n<li>sleep()：静态方法，使当前线程睡眠一段时间；</li>\n<li>join()：使当前线程等待另一个线程执行完毕之后再继续执行，内部调用的是Object类的wait方法实现的；</li>\n</ul>\n<h5 id=\"2-1-5-Thread类和Runnable接口的比较\"><a href=\"#2-1-5-Thread类和Runnable接口的比较\" class=\"headerlink\" title=\"2.1.5 Thread类和Runnable接口的比较\"></a>2.1.5 Thread类和Runnable接口的比较</h5><ul>\n<li>由于Java“单继承，多实现”的特性，Runnable接口使用起来比Thread更灵活。</li>\n<li>Runnable接口出现更符合面向对象，将线程单独进行对象的封装。</li>\n<li>Runnable接口出现，降低了线程对象和线程任务的耦合性。</li>\n<li>如果使用线程时不需要使用Thread类的诸多方法，显然使用Runnable接口更为轻量。</li>\n</ul>\n<p>所以，我们通常优先使用“实现<code>Runnable</code>接口”这种方式来自定义线程类。</p>\n<h4 id=\"2-2-Callable、Future与FutureTask\"><a href=\"#2-2-Callable、Future与FutureTask\" class=\"headerlink\" title=\"2.2 Callable、Future与FutureTask\"></a>2.2 Callable、Future与FutureTask</h4><p>使用上述的两种方式实现多线程又一个弊端，就是<code>run()</code>方法没有返回值。</p>\n<p>JDK给我们提供了<code>Callable</code>接口与<code>Future</code>类为我们解决这个问题，这也是所谓的“异步”模型。</p>\n<h5 id=\"2-2-1-Callable接口\"><a href=\"#2-2-1-Callable接口\" class=\"headerlink\" title=\"2.2.1 Callable接口\"></a>2.2.1 Callable接口</h5><p><code>Callable</code>接口和<code>Runnable</code>接口类似，也是一个函数式接口，不同之处在于前者的<code>run()</code>方法有返回值，并且支持泛型。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@FunctionalInterface\npublic interface Callable&lt;V&gt; &#123;\n    V call() throws Exception;\n&#125;</code></pre>\n\n<p><code>Callable</code>接口一般是配合线程池工具<code>ExcutorService</code>使用的，这里只介绍<code>ExecutorService</code>可以使用<code>submit</code>方法来让一个<code>Callable</code>接口执行。它会返回一个<code>Future</code>，我们后续的程序可以通过这个<code>Future</code>的<code>get</code>方法得到结果。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 自定义Callable\nclass Task implements Callable&lt;Integer&gt;&#123;\n    @Override\n    public Integer call() throws Exception &#123;\n        &#x2F;&#x2F; 模拟计算需要一秒\n        Thread.sleep(1000);\n        return 2;\n    &#125;\n    public static void main(String args[])&#123;\n        &#x2F;&#x2F; 使用\n        ExecutorService executor &#x3D; Executors.newCachedThreadPool();\n        Task task &#x3D; new Task();\n        Future&lt;Integer&gt; result &#x3D; executor.submit(task);\n        &#x2F;&#x2F; 注意调用get方法会阻塞当前线程，直到得到结果。\n        &#x2F;&#x2F; 所以实际编码中建议使用可以设置超时时间的重载get方法。\n        System.out.println(result.get()); \n    &#125;\n&#125;</code></pre>\n\n<p>输出结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">2</code></pre>\n\n<h5 id=\"2-2-2-Future接口\"><a href=\"#2-2-2-Future接口\" class=\"headerlink\" title=\"2.2.2 Future接口\"></a>2.2.2 Future接口</h5><p><code>Future</code>接口只有几个比较简单的方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract interface Future&lt;V&gt; &#123;\n    public abstract boolean cancel(boolean paramBoolean);\n    public abstract boolean isCancelled();\n    public abstract boolean isDone();\n    public abstract V get() throws InterruptedException, ExecutionException;\n    public abstract V get(long paramLong, TimeUnit paramTimeUnit)\n            throws InterruptedException, ExecutionException, TimeoutException;\n&#125;</code></pre>\n\n<p><code>cancel</code>方法是试图取消一个线程的执行。</p>\n<p>注意是<strong>试图</strong>取消，<strong>并不一定能取消成功</strong>。因为任务可能已完成、已取消、或者一些其它因素不能取消，存在取消失败的可能。<code>boolean</code>类型的返回值是“是否取消成功”的意思。参数<code>paramBoolean</code>表示是否采用中断的方式取消线程执行。</p>\n<p>所以有时候，为了让任务有能够取消的功能，就使用<code>Callable</code>来代替<code>Runnable</code>。如果为了可取消性而使用 <code>Future</code>但又不提供可用的结果，则可以声明 <code>Future&lt;?&gt;</code>形式类型、并返回 <code>null</code>作为底层任务的结果。</p>\n","text":"Java多线程知识第一篇：基础篇第一章：进程与线程的基本概念1.1 线程和进程的一些概念进程的提出：由于批处理操作系统的指令运行方式仍然是串行的，内存中始终只有一个程序在运行，后面的程序需要等待前面的程序执行完成后才能开始执行，而前面的程序有时会由于I/O操作、网络等原因阻塞，所以批处理操作效率也不高。 进程的概念：进程就是应用程序在内存中分配的空间，也就是正在运行的程序，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态。 上下文切换：CPU为每个进程分配一个时间段，称作它的时间片。如果在时间片结束时进程还在运行，则暂停这个进程的运行，并且CPU分配给另一个进程。 当进程暂停时，它...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[{"name":"并发编程","slug":"并发编程","count":1,"path":"api/categories/并发编程.json"}],"tags":[{"name":"笔记","slug":"笔记","count":11,"path":"api/tags/笔记.json"},{"name":"并发编程","slug":"并发编程","count":1,"path":"api/tags/并发编程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">Java多线程知识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E7%AF%87%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87\"><span class=\"toc-text\">第一篇：基础篇</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">第一章：进程与线程的基本概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.1 线程和进程的一些概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2\"><span class=\"toc-text\">1.2 上下文切换</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9AJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">第二章：Java多线程入门类和接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-Thread%E7%B1%BB%E5%92%8CRunnable%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">2.1 Thread类和Runnable接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-1-1-%E7%BB%A7%E6%89%BFThread%E7%B1%BB\"><span class=\"toc-text\">2.1.1 继承Thread类</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-1-2-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">2.1.2 实现Runnable接口</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-1-3-Thread%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.1.3 Thread类的构造方法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-1-4-Thread%E7%B1%BB%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.1.4 Thread类的几个常用方法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-1-5-Thread%E7%B1%BB%E5%92%8CRunnable%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">2.1.5 Thread类和Runnable接口的比较</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-Callable%E3%80%81Future%E4%B8%8EFutureTask\"><span class=\"toc-text\">2.2 Callable、Future与FutureTask</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-1-Callable%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">2.2.1 Callable接口</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-2-Future%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">2.2.2 Future接口</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Cao Wei","slug":"blog-author","avatar":"https://uploadfiles.nowcoder.com/images/20210823/575528905_1629692577639/4B05D951868901CDA3382C7B70543CD5","link":"/","description":"Code makes world better","socials":{"github":"https://github.com/wavecao","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Volatile笔记","uid":"bba89471be59517c19dfa618326fae4f","slug":"Volatile笔记","date":"2020-08-19T03:14:00.000Z","updated":"2020-08-19T03:15:12.000Z","comments":true,"path":"api/articles/Volatile笔记.json","keywords":null,"cover":[],"text":"1. 概念volatile 是 Java 中的关键字，是一个变量修饰符，用来修饰会被不同线程访问和修改的变量。 2. 内存模型的3个特性2.1 可见性可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。 可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。 在 Java 中 volatile、synchronized 和 final 都可以实现可见性。 2.2 原...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"笔记","slug":"笔记","count":1,"path":"api/categories/笔记.json"}],"tags":[{"name":"笔记","slug":"笔记","count":11,"path":"api/tags/笔记.json"}],"author":{"name":"Cao Wei","slug":"blog-author","avatar":"https://uploadfiles.nowcoder.com/images/20210823/575528905_1629692577639/4B05D951868901CDA3382C7B70543CD5","link":"/","description":"Code makes world better","socials":{"github":"https://github.com/wavecao","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"单例模式详解","uid":"a38aadce42dddbcde7f41fcb5e12b8a9","slug":"单例模式","date":"2020-07-28T09:02:00.000Z","updated":"2020-07-28T09:03:02.000Z","comments":true,"path":"api/articles/单例模式.json","keywords":null,"cover":null,"text":"单例模式一、什么是单例模式 单例类只能有一个实例 必须自行创建自己的唯一实例 向所有其他对象提供这一实例 二、单例模式的分类饿汉式：在类加载时候就创建单例（不管是否需要使用，都会先创建） 懒汉式：在需要使用实例的时候才创建 三、代码实现单例模式的核心思想： 定义私有静态对象作为该类的唯一实例obj。 私有化构造函数，保证用户不可以直接通过构造函数创建该类实例，或直接访问该类实例。 定义一个公有的getInstance()方法去获得该类的唯一单例obj。 饿汉式：方法一静态常量：将唯一实例instance设置为静态常量 public class Singleton1 &#123; private...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"设计模式","slug":"设计模式","count":1,"path":"api/categories/设计模式.json"}],"tags":[{"name":"笔记","slug":"笔记","count":11,"path":"api/tags/笔记.json"},{"name":"设计模式","slug":"设计模式","count":1,"path":"api/tags/设计模式.json"}],"author":{"name":"Cao Wei","slug":"blog-author","avatar":"https://uploadfiles.nowcoder.com/images/20210823/575528905_1629692577639/4B05D951868901CDA3382C7B70543CD5","link":"/","description":"Code makes world better","socials":{"github":"https://github.com/wavecao","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}