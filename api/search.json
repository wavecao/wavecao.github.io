[{"id":"691d8376b81ffef877a8c1d1ab0e65db","title":"MySQL是怎样运行的(一)——初识MySQL","content":"\n\n\n\n\n\n\n\n\n本文所有知识点整理自掘金小册《MySQL 是怎样运行的：从根儿上理解 MySQL》，内容充实，难度适中，通俗易懂，有助于理解Mysql的运行原理，建议购买支持一下！（说真的，白嫖我整理的知识点根本没法领略到小册的魅力，也学不到东西）\n初识Mysql基础细碎知识\n启动MySQL客户端命令\nmysql -h主机名  -u用户名 -p密码\n\n\n\n\n参数名\n含义\n\n\n\n-h    \n表示服务器进程所在计算机的域名或者IP地址，如果服务器进程就运行在本机的话，可以省略这个参数，或者填localhost或者127.0.0.1。也可以写作 --host=主机名的形式。本地的话, 可以省略:smile:\n\n\n-u\n表示用户名。也可以写作 --user=用户名的形式。\n\n\n-p\n表示密码。也可以写作 --password=密码的形式。\n\n\n举个栗子\nmysql -uroot -p19981008\n\n另外, 各个参数的顺序没有硬性要求\n\nMySQL采用TCP作为服务器和客户端之间通信的网络通信协议; MySQL服务器会默认监听3306端口。\n\n如果3306端口被占用或者想自定义数据库实例监听的端口号, 可以在启动服务器程序的命令行中指定, 比如: \nmysqld -P3307\n\n服务器处理客户端请求客户端向服务端发送增删改查请求后, 服务端的大致流程如下图: \n\n从图中我们可以看出，服务器程序处理来自客户端的查询请求大致需要经过三个部分，分别是连接管理、解析与优化、存储引擎。\n连接管理MySQL使用连接池管理客户端的链接, 每次客户端断开连接后将线程缓存起来以便下次分配(我们可以自己限制线程的数量); 如果客户端与服务端不运行在同一台机器上, 还会使用SSL(安全套接字)的网络连接进行通信, 来保证数据的安全传输; \n解析与优化\n查询缓存\nMySQL会把刚刚处理过的请求和结果缓存起来，如果有相同的请求过来，就直接从缓存中找出结果；缓存可以在客户端之间共享\n如果两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。另外，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。\nMySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了INSERT、 UPDATE、DELETE、TRUNCATE TABLE、ALTER TABLE、DROP TABLE或 DROP DATABASE语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！\n虽然缓存可以提高性能, 但缓存本身也会造成开销, 从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。\n\n\n语法解析\n服务器对接收到的文本做分析, 首先判断是否有语法错误, 之后就从文本中获取到要查询的表以及各种查询条件进行查询;\n\n\n查询优化\n我们自己写的SQL语句往往比较菜, MySQL会对我们的语句做一些优化, 比如说外连接转化为内连接, 表达式简化, 子查询转为连接等等;\n可以使用EXPLAIN语句来查看某个语句的执行计划;\n\n\n\n存储引擎MySQL把数据的存储和提取操作都封装到了一个叫存储引擎的模块里; \n常见存储引擎:\n\n\n\n存储引擎\n描述\n\n\n\nARCHIVE\n用于数据存档(行被插入后不能再修改)\n\n\nBLACKHOLE\n丢弃写操作,读操作会返回空内容\n\n\nCSV\n在存储数据时，以逗号分隔各个数据项\n\n\nFEDERATED\n用来访问远程表\n\n\nInnoDB\n具备外键支持功能的事务存储引擎，而且同时支持表级锁和行级锁\n\n\nMEMORY\n置于内存的表\n\n\nMERGE\n用来管理多个MyISAM表构成的表集合\n\n\nMyISAM\n主要的非事务处理存储引擎\n\n\nNDB\nMySQL集群专用存储引擎\n\n\n关于存储引擎的一些操作查看当前使用的存储引擎show engines;\n\n\n其中的Support列表示该存储引擎是否可用，DEFAULT值代表是当前服务器程序的默认存储引擎。Transactions列代表该存储引擎是否支持事务处理。XA列代表着该存储引擎是否支持分布式事务。Savepoints代表着该存储引擎是否支持部分事务回滚。\n设置表的存储引擎可以为不同的表设置不同的存储引擎，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。\n创建时就指定存储引擎创建数据表时如果没有指定存储引擎，那就会使用默认的存储引擎InnoDB，如果想显式地指定存储引擎可以使用下面地语句：\nCREATE TABLE 表名(\n    建表语句;\n) ENGINE &#x3D; 存储引擎名称;\n\n比如我们想创建一个使用MyISAM引擎地表，可以这么写：\nmysql&gt; CREATE TABLE engine_demo_table(\n    -&gt;     i int\n    -&gt; ) ENGINE &#x3D; MyISAM;\nQuery OK, 0 rows affected (0.02 sec)\n\n修改表的存储引擎ALTER TABLE 表名 ENGINE &#x3D; 存储引擎名称;\n\n","slug":"MySQL是怎样运行的(一)——初始MySQL","date":"2020-08-22T02:54:00.000Z","categories_index":"MySQL","tags_index":"MySQL,笔记","author_index":"Cao Wei"},{"id":"81b01b0fe0649b3c1227863a4d704276","title":"Linux学习笔记——一篇入门Linux","content":"Linux学习笔记1. Linux简介简介Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。\nLinux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。\nLinux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。\n发行版Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。\n\n目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。\n\nLinux和Windows的对比\n2. Linux的目录结构登录系统后，在终端输入：\nls &#x2F;\n\n你会看到以下图示：\n\n树状目录结构为：\n\n有关目录的解释：\n\n/bin：\nbin是Binary的缩写，/bin 放置的是在单人维护模式下还能够被操作的指令。在/bin底下的指令可以被root与一般账号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash 等等常用的指令。\n\n/boot：\n这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。\n\n/dev：\ndev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。因为Linux中一切皆文件！\n\n/etc：\n这个目录用来存放所有的系统管理所需要的配置文件和子目录。例如人员的账号密码文件、 各种服务的启始档等等。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的， 但是只有 root 有权力修改。\n\n/home：\n用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，比如在我的系统中只有cheerway这一个用户。\n\n~：代表目前这个用户的目录\n\n\n\n/lib：\n这个目录存放着系统最基本的动态链接共享库，其作用类似于Windows中的DLL文件。几乎所有的应用程序都要使用到这些共享库。\n\n/lost+found：\n这个目录一般是空的，当系统非法关机以后，这里就存了一些文件。也就是说当文件系统发生错误时，这里就遗留了一些片段。\n\n/media：\nlinux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。\n\n/mnt：\n系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了\n\n/opt：\n这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。不过有的人喜欢把软件放在usr/local。这个因人而异吧。\n\n/proc：\n这个目录本身是一个虚拟文件系统(virtual filesystem)！他放置的数据都是在内存当中， 例如系统核心、进程信息(process)、周边装置的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！比较重要的文件例如：/proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/等等。\n这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：\necho 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all\n\n进入该目录下，输入如下命令可以一窥cpuinfo文件的内容，但是具体内容我也看不懂/(ㄒoㄒ)/~~：\ncat cpuinfo\n\n\n\n/root：\n该目录为系统管理员，也称作超级权限者的用户主目录。\n\n/sbin：\ns就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。放在/sbin 底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些服务器软件程序，一般则放置到/usr/sbin/当中。至于本机自行安装的软件所产生的系统执行文件(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, mkfs 等等。\n\n/selinux：\n这个目录是Redhat和CentO S所特有的目录，Selinux是一个安全机制，类似于Windows的防火墙，但是这套机制比较复杂，而这个目录就是用来存放Selinux相关的文件的。\n\n/srv：\n该目录存放一些服务启动之后需要提取的数据。\n\n/sys：\n这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。\nsysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。\n该文件系统是内核设备树的一个直观反映。\n当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。\n\n/tmp：这个目录是用来存放一些临时文件的。\n\n/usr： 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。\n\n/usr/bin：系统用户使用的应用程序。\n\n/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。\n\n/usr/src：内核源代码默认的放置目录。\n\n/var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。\n\n/run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。\n\n\n在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。\n\n/etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。\n\n/bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。\n值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给root使用的指令。\n\n/var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外mail的预设放置也是在这里。\n\n\n3. Linux文件基本属性基本属性Linux系统是一个典型的多用户系统，不同的用户有不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件的权限做了不同的规定。\n可以使用ls -l或者ll命令查看一个文件的属性以及文件所属的用户和组，比如：\n\n实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。\n在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。\n\n当为[ d ]则是目录\n当为[ - ]则是文件；\n若是[ l ]则表示为链接文档(link file)；\n若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；\n若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。\n\n接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。\n每个文件的属性由左边第一部分的10个字符来确定（如下图）:\n\n\n\n\n\n\n\n\n\n\n对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。\n同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。\n文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。\n因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。\n对于 root 用户来说，一般情况下，文件的权限对其不起作用。\n更改文件属性\nchgrp：更改文件属组\n语法：\nchgrp [-R] 属性组 文件名\n\n参数选项：\n\n-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。\n\n\nchown：更改文件属主，也可以同时更改其属组\n语法：\nchown [-R] 属主名 文件名\nchown [-R] 属主名：属组名 文件名\n\n举例：进入 /root 目录（~）将install.log的拥有者改为bin这个账号：\n[root@www ~] cd ~\n[root@www ~]# chown bin install.log\n[root@www ~]# ls -l\n-rw-r--r--  1 bin  users 68495 Jun 25 08:53 install.log\n\n将install.log的拥有者与群组改回为root：\n[root@www ~]# chown root:root install.log\n[root@www ~]# ls -l\n-rw-r--r--  1 root root 68495 Jun 25 08:53 install.log\nchmod：更改文件9个属性\nLinux文件属性有两种设置方法，一种是数字，一种是符号。\nLinux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。\n先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：\n\nr:4\nw:2\nx:1\n\n每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：\n\nowner = rwx = 4+2+1 = 7\ngroup = rwx = 4+2+1 = 7\nothers= — = 0+0+0 = 0\n\n所以等一下我们设定权限的变更时，该文件的权限数字就是770啦！变更权限的指令chmod的语法是这样的：\nchmod [-R] xyz 文件名或目录\n\n选项与参数：\n\nxyz：分别代表三个数字，为rwx属性值的相加\n-R：进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更\n\n举例来说，如果要将一个文件的权限更改为 -rwxr-xr-- 的话，那么权限的分数就是：\n[4+2+1] [4+0+1] [4+0+0] = 754。\n符号类型改变文件权限\n还有一个改变权限的方法，从之前的介绍中我们可以发现，基本上就九个权限分别是：\n\n(1)user\n(2)group\n(3)others\n\n那么我们就可以使用 u, g, o 来代表三种身份的权限！\n此外， a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x，也就是可以使用下表的方式来看：\n\n\n\nchmod\nu\n+ 加入\nr\n文件名/目录\n\n\n\n\ng\n- 除去\nw\n\n\n\n\no\n= 设定\nx\n\n\n\n\na\n\n\n\n\n\n如果我们需要将文件权限设置为 -rwxr-xr– ，可以使用 chmod u=rwx,g=rx,o=r 文件名 来设定：\n#  touch test1    &#x2F;&#x2F; 创建 test1 文件\n# ls -al test1    &#x2F;&#x2F; 查看 test1 默认权限\n-rw-r--r-- 1 root root 0 Nov 15 10:32 test1\n# chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;r  test1    &#x2F;&#x2F; 修改 test1 权限\n# ls -al test1\n-rwxr-xr-- 1 root root 0 Nov 15 10:32 test1\n\n而如果是要将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：\n#  chmod  a-x test1\n# ls -al test1\n-rw-r--r-- 1 root root 0 Nov 15 10:32 test1\n\n4. Linux文件与目录管理Linux的目录结构为树状结构，最顶级的目录为根目录 /。\n其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。\n在开始本教程前我们需要先知道什么是绝对路径与相对路径。\n\n绝对路径：路径的写法，由根目录 / 写起，例如： /usr/share/doc 这个目录。\n相对路径：路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： cd ../man 这就是相对路径的写法啦！\n\n处理文件的常用指令\nls: 列出目录及文件名\ncd：切换目录\npwd：显示目前的目录\nmkdir：创建一个新的目录\nrmdir：删除一个空的目录\ncp: 复制文件或目录\nrm: 移除文件或目录\nmv: 移动文件与目录，或修改文件与目录的名称\n\n可以使用 man [命令] 来查看各个命令的使用文档，如 ：man cp。\nls：列出目录语法：\n[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称\n[root@www ~]# ls [--color&#x3D;&#123;never,auto,always&#125;] 目录名称\n[root@www ~]# ls [--full-time] 目录名称\n\n选项与参数：\n\n-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)\n-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)\n-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)\n\n\ncd：切换目录cd是Change Directory的缩写，这是用来变换工作目录的命令。\n语法：\ncd [相对路径或绝对路径]\n\npwd ：显示目前所在的目录pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的命令。\n语法：\npwd [-P]\n\n选项与参数：\n\n-P ：显示出确实的路径，而非使用连结 (link) 路径。\n\n实例：单纯显示出目前的工作目录：\n\n上图就直接显示了目录本身，下面是一个带参数的实例：\n[root@www ~]# cd &#x2F;var&#x2F;mail   &lt;&#x3D;&#x3D;注意，&#x2F;var&#x2F;mail是一个连结档\n[root@www mail]# pwd\n&#x2F;var&#x2F;mail         &lt;&#x3D;&#x3D;列出目前的工作目录\n[root@www mail]# pwd -P\n&#x2F;var&#x2F;spool&#x2F;mail   &lt;&#x3D;&#x3D;怎么回事？有没有加 -P 差很多～\n[root@www mail]# ls -ld &#x2F;var&#x2F;mail\nlrwxrwxrwx 1 root root 10 Sep  4 17:54 &#x2F;var&#x2F;mail -&gt; spool&#x2F;mail\n# 看到这里应该知道为啥了吧？因为 &#x2F;var&#x2F;mail 是连结档，连结到 &#x2F;var&#x2F;spool&#x2F;mail \n# 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径啊！\n\nmkdir：创建目录语法：\nmkdir [-mp] 目录名称\n\n选项与参数：\n\n-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～\n-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！\n\n实例：\n\n加了 -p 的选项，可以自行帮你创建多层目录\n也可以在创建目录的时候指定权限，创建权限为 rwx–x–x 的目录：\n\nrmdir：删除空的目录语法：\nrmdir [-p] 目录名称\n\n选项与参数：\n\n-p ：连同上一级『空的』目录也一起删除\n\n不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。\ncp：复制文件或者目录语法:\ncp [-adfilprsu] 来源档(source) 目标档(destination)\ncp [options] source1 source2 source3 .... directory\n\n选项与参数：\n\n-a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)\n-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；\n-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；\n-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)\n-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身；\n-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；\n-r：递归持续复制，用於目录的复制行为；(常用)\n-s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；\n-u：若 destination 比 source 旧才升级 destination ！\n\n\n\n\n\n\n\n\n\n\n值得一提的是，在修改任何重要的文件之前利用cp进行备份是非常必要的\nrm：删除文件或者目录:slightly_smiling_face:终于迎来了删库跑路用的命令！\n语法：\nrm [-fir] 文件或者目录\n\n选项与参数：\n\n-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；\n-i ：互动模式，在删除前会询问使用者是否动作\n-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！\n\n如果你想强制递归删除某个东西，比如你公司的数据库文件，可以使用：\nrm -rf 数据库文件夹\n\n做完这一步操作，恭喜你可以跳槽加薪了！\nmv：移动文件与目录或者修改名称语法：\nmv [-fiu] source destination\nmv [options] source1 source2 source3 .... directory\n\n选项与参数：\n\n-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；\n-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！\n-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)\n\nLinux文件内容查看Linux系统中使用以下命令来查看文件的内容：\n\ncat 由第一行开始显示文件内容\ntac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！\nnl  显示的时候，顺道输出行号！\nmore 一页一页的显示文件内容\nless 与 more 类似，但是比 more 更好的是，他可以往前翻页！\nhead 只看头几行\ntail 只看尾巴几行\n\ncat：由第一行开始显示文件内容语法：\ncat [-AbEnTv]\n\n选项与参数：\n\n-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；\n-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！\n-E ：将结尾的断行字节 $ 显示出来；\n-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；\n-T ：将 [tab] 按键以 ^I 显示出来；\n-v ：列出一些看不出来的特殊字符\n\n实例：\n\ntac：从最后一行开始查看\n\n\n\n\n\n\n\n\n如果你仔细看的话，会发现tac其实是cat反过来，他们表达的意思也是相反的\n示例：\n\n确实是倒过来了，很迷惑这个命令的作用是什么？:confused:\nnl：显示行号语法：\nnl [-bnw] 文件\n\n选项与参数：\n\n-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；\n-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；\n-w ：行号栏位的占用的位数。\n\n示例：\n\nmore：一页一页翻动示例：\n\n在 more 这个程序的运行过程中，你有几个按键可以按的：\n\n空白键 (space)：代表向下翻一页；\nEnter     ：代表向下翻『一行』；\n/字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；\n:f      ：立刻显示出档名以及目前显示的行数；\nq       ：代表立刻离开 more ，不再显示该文件内容。\nb 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。\n\n高级用法：\nmore +3 test.log  #从第三行开始显示\nmore -4 test.log  #每屏显示四行内容\nmore +&#x2F;java test.log  #从第一个java关键字处前两行开始显示\n\n\n\nless：一页一页翻动less 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大。less 的用法比起 more 更加的有弹性。在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。\nless运行时可以输入的命令有：\n\n空白键  ：向下翻动一页；\n[pagedown]：向下翻动一页；\n[pageup] ：向上翻动一页；\n/字串   ：向下搜寻『字串』的功能；\n?字串   ：向上搜寻『字串』的功能；\nn     ：重复前一个搜寻 (与 / 或 ? 有关！)\nN     ：反向的重复前一个搜寻 (与 / 或 ? 有关！)\nq     ：离开 less 这个程序；\n\nhead：取出文件内容的开头部分语法：\nhead [-n number] 文件名\n\n示例：\n\n选项与参数：\n\n-n ：后面接数字，代表显示几行的意思\n\n默认显示前十行\ntail：取出文件末尾的内容tail [-n number] 文件名\n\n示例：\n\n选项与参数：\n\n-n ：后面接数字，代表显示几行的意思\n-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测\n\n&gt;指令和&gt;&gt;指令&gt; 输出重定向：会将原来的文件内容覆盖\n&gt;&gt; 追加，不会覆盖原来的内容，而是追加在文件尾部\n示例：\n\n再次使用ls -l &gt; a.txt ，这次不加-a参数：\n\n再次输入ls -al &gt;&gt; a.txt：\n\n示例：将文件1的内容覆盖到文件2\ncat 文件1 &gt; 文件2\n\necho指令语法：\necho [options] 输出的内容\n\n示例：使用echo指令输出环境变量\necho $PATH\n\n\nhistory指令查看已经执行过的历史命令，也可以执行历史命令\n语法：\nhistory n\n\n\n\n\n\n\n\n\n\n\nn表示要显示的个数\n示例：最近使用的全部指令\n\n示例：最近使用的五条指令\n\n示例：执行标号为17的指令\n\nfind指令find指令将从指定目录向下递归地遍历其各个子目录，将满足条件地文件或者目录显示在终端。\n语法：\nfind 搜索范围 [选项]\n\n选项说明：\n\n\n\n选项\n功能\n\n\n\n-name&lt;查询方式&gt;\n按照指定的文件名查找模式查找文件\n\n\n-user&lt;用户名&gt;\n查找属于指定用户名的所有文件\n\n\n-size&lt;文件大小&gt;\n按照指定的文件大小查找文件\n\n\n示例：根据文件名查找文件\n\n根据拥有者查找文件\n\n查找整个Linux系统中大于20M的文件（+n 大于，-n小于，n等于）\n\n查找所有的.txt文件\n\nlocate指令locate 可以快速定位文件路径。locate指令利用事先建立好的系统中所有文件名称及其路径的locate数据库实现快速定位给定的文件。\nlocate无需遍历整个文件系统，所以速度非常快，为了保证查询结果的精确性，管理员必须定期更新locate数据库\n语法：\nlocate 文件名\n\n\n\n\n\n\n\n\n\n\n由于locate指令基于数据库进行查询，所以第一次运行前，必需使用updatedb指令创建数据库\n示例：使用locate快速定位a.txt文件所在的目录\n\n5. Linux用户与用户组管理Linux 用户管理Linux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。\n用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。\nLinux 用户管理相关命令:\n\nuseradd 选项 用户名:添加用户账号\nuserdel 选项 用户名:删除用户帐号\nusermod 选项 用户名:修改帐号\npasswd 用户名:更改或创建用户的密码\npasswd -S 用户名 :显示用户账号密码信息\npasswd -d 用户名: 清除用户密码\n\nuseradd 命令用于 Linux 中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在 /etc/passwd文本文件中。\npasswd命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。\nLinux 系统用户组的管理每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同，如 Linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。\n用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。\nLinux 系统用户组的管理相关命令:\n\ngroupadd 选项 用户组 :增加一个新的用户组\ngroupdel 用户组:要删除一个已有的用户组\ngroupmod 选项 用户组 : 修改用户组的属性\n\n6. 压缩与解压缩命令打包并压缩文件Linux 中的打包文件一般是以.tar 结尾的，压缩的命令一般是以.gz 结尾的。而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。 命令：tar -zcvf 打包压缩后的文件名 要打包压缩的文件 ，其中：\n\nz：调用 gzip 压缩命令进行压缩\nc：打包文件\nv：显示运行过程\nf：指定文件名\n\n比如：假如 test 目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包 test 目录并指定压缩后的压缩包名称为 test.tar.gz 可以使用命令：**tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt 或 tar -zcvf test.tar.gz /test/**\n解压压缩包命令：tar [-xvf] 压缩文件\n其中：x：代表解压\n示例：\n\n将 /test 下的 test.tar.gz 解压到当前目录下可以使用命令：**tar -xvf test.tar.gz**\n将 /test 下的 test.tar.gz 解压到根目录/usr 下:**tar -xvf test.tar.gz -C /usr**（- C 代表指定解压的位置）\n\n7. grep指令和管道符号 |grep：过滤查找\n管道符号：| 表示将前一个命令的处理结果输出传递后后面的命令处理\n语法：\ngrep [选项] 查找内容 源文件\n\n选项说明：\n\n-n：显示匹配行及行号\n-i：忽略字母大小写\n\n示例：在b.txt文件中，查找yes所在行并显示行号\n\n8. 磁盘情况查询命令查询磁盘整体使用情况语法：\ndf -lh\n\n\n查看指定目录的磁盘占用情况语法：\ndu -h &#x2F;目录\n\n选项说明：\n\n-s：指定目录占用的大小汇总\n-h：带计量单位\n-a：含文件\n–max-depth=1 子目录深度\n-c：列出明细的同时，增加汇总值\n\n示例：查看/opt 目录的占用情况，深度为1\n\n一些实用指令\n统计/home文件夹下文件的个数\n\n\n统计/home文件夹下文件夹的个数\n\n\n统计/home文件夹下的文件个数（或者文件夹个数），包含子文件夹里的\n\n\n以树状显示目录结构\n使用之前需要yum install tree才能使用tree命令！\n\n\n\n\n\n\n\n\n\n\n\nwc命令用于计算字数。利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。\n语法：wc [-clw][--help][--version][文件...] \n参数说明：\n\n-c或–bytes或–chars 只显示Bytes数。\n-l或–lines 只显示行数。\n-w或–words 只显示字数。\n–help 在线帮助。\n–version 显示版本信息。\n\n在默认的情况下，wc将计算指定文件的行数、字数，以及字节数。使用的命令为：\nwc filename\n结果是：3 92 598 testfile       # testfile文件的行数为3、单词数92、字节数598 \n9. 进程管理进程的基本介绍\n显示系统执行的进程查看进程使用的命令是：ps，一般来说使用的参数是ps -aux\n\n-a：显示所有的进程信息\n-u：以用户的格式显示进程信息\n-x：显示后台进程运行的参数\n\n示例：\n\n参数详细说明：\n\n示例：以全格式显示当前所有的进程，查看进程的父进程\n\n参数详细说明：\n\n终止进程kill和killall语法：\nkill [选项] 进程号 （通过进程号杀死进程）\nkillall 进程名称 (通过名称杀死进程，也支持通配符，这在系统因负载过大而变慢时很有用)\n\n选项说明：\n\n-9：强迫进程立即停止\n\n查看进程树pstree语法：\npstree [选项]\n\n选项说明：\n\n-p：显示进程的PID\n-u：显示进程的所属用户\n\n\n动态监控进程介绍top与ps命令很相似。他们都是用来显示正在执行的进程。top与ps最大的不同之处在于top在执行一段时间内可以更新正在运行的进程\ntop指令语法：\ntop [选项]\n\n选项说明：\n\n-d 秒数：指定top指令每隔几秒更新，默认是3秒\n-i：使top不显示任何闲置或者僵尸jinc\n-p：通过指定监控进程的ID来监控特定的进程状态\n\n交互操作说明：\n\nP：以CPU使用率排序，默认就是此项\nM：以内存的使用率排序\nN：以PID排序\nq：退出指令\n\n示例：输入top命令\n\n然后再输入”u“，再输入用户名，即可监控指定用户名的进程\n\n输入”k“，在输入要结束的进程ID，即可杀死进程\n示例：指定10秒更新一次\ntop -d 10\n\n查看网络情况netstat（重要！！！）语法：\nnetstat [-anp] \n\n选项说明：\n\n-an：按一定的顺序排列\n-p：显示哪个进程在调用\n\n示例：查看所有的网络连接\n\n示例：查看所有的tcp连接\n\n","slug":"Linux学习笔记","date":"2020-08-20T01:47:00.000Z","categories_index":"Linux","tags_index":"笔记,Linux","author_index":"Cao Wei"},{"id":"bba89471be59517c19dfa618326fae4f","title":"Volatile笔记","content":"1. 概念volatile 是 Java 中的关键字，是一个变量修饰符，用来修饰会被不同线程访问和修改的变量。\n\n2. 内存模型的3个特性2.1 可见性可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。\n可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。\n在 Java 中 volatile、synchronized 和 final 都可以实现可见性。\n2.2 原子性原子性指的是某个线程正在执行某个操作时，中间不可以被加塞或分割，要么整体成功，要么整体失败。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作是原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。Java 的 concurrent 包下提供了一些原子类，AtomicInteger、AtomicLong、AtomicReference等。\n在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。\n2.3 有序性Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作“这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。\n\n3. volatile 是 Java 虚拟机提供的轻量级的同步机制\n保证可见性\n不保证原子性\n禁止指令重排（保证有序性）\n\n3.1 空说无凭，代码验证3.1.1 可见性验证class MyData &#123;\n    int number &#x3D; 0;\n    public void add() &#123;\n        this.number &#x3D; number + 1;\n    &#125;\n&#125;\n\n   &#x2F;&#x2F; 启动两个线程，一个work线程，一个main线程，work线程修改number值后，查看main线程的number\n   private static void testVolatile() &#123;\n        MyData myData &#x3D; new MyData();\n\n        new Thread(() -&gt; &#123;\n            System.out.println(Thread.currentThread().getName()+&quot;\\t come in&quot;);\n            try &#123;\n                TimeUnit.SECONDS.sleep(2);\n                myData.add();\n                System.out.println(Thread.currentThread().getName()+&quot;\\t update number value :&quot;+myData.number);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;, &quot;workThread&quot;).start();\n\n        &#x2F;&#x2F;第2个线程，main线程\n        while (myData.number &#x3D;&#x3D; 0)&#123;\n            &#x2F;&#x2F;main线程还在找0\n        &#125;\n        System.out.println(Thread.currentThread().getName()+&quot;\\t mission is over&quot;);      \n        System.out.println(Thread.currentThread().getName()+&quot;\\t mission is over，main get number is:&quot;+myData.number);\n    &#125;\n&#125;Copy to clipboardErrorCopied\n\n运行 testVolatile() 方法，输出如下，会发现在 main 线程死循环，说明 main 线程的值一直是 0\nworkThread     execute\nworkThread     update number value :1Copy to clipboardErrorCopied\n\n修改 volatile int number = 0,，在 number 前加关键字 volatile,重新运行，main 线程获取结果为 1\nworkThread     execute\nworkThread     update number value :1\nmain     execute over，main get number is:1Copy to clipboardErrorCopied\n\n3.1.2 不保证原子性验证class MyData &#123;\n    volatile int number &#x3D; 0;\n    public void add() &#123;\n        this.number &#x3D; number + 1;\n    &#125;\n&#125;\n\nprivate static void testAtomic() throws InterruptedException &#123;\n  MyData myData &#x3D; new MyData();\n\n  for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n    new Thread(() -&gt;&#123;\n      for (int j &#x3D; 0; j &lt; 1000; j++) &#123;\n        myData.addPlusPlus();\n      &#125;\n    &#125;,&quot;addPlusThread:&quot;+ i).start();\n  &#125;\n\n\n  &#x2F;&#x2F;等待上边20个线程结束后(预计5秒肯定结束了)，在main线程中获取最后的number\n  TimeUnit.SECONDS.sleep(5);\n  while (Thread.activeCount() &gt; 2)&#123;\n    Thread.yield();\n  &#125;\n  System.out.println(&quot;final value：&quot;+myData.number);\n&#125;Copy to clipboardErrorCopied\n\n运行 testAtomic 发现最后的输出值，并不一定是期望的值 10000，往往是比 10000 小的数值。\nfinal value：9856Copy to clipboardErrorCopied\n\n为什么会这样呢，因为 i++ 在转化为字节码指令的时候是4条指令\n\ngetfield 获取原始值\niconst_1 将值入栈\niadd 进行加 1 操作\nputfield 把 iadd 后的操作写回主内存\n\n这样在运行时候就会存在多线程竞争问题，可能会出现了丢失写值的情况。\n\n如何解决原子性问题呢？\n加 synchronized 或者直接使用 Automic 原子类。\n3.1.3 禁止指令重排验证计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排，一般分为以下 3 种\n\n处理器在进行重排序时必须要考虑指令之间的数据依赖性，我们叫做 as-if-serial 语义\n单线程环境里确保程序最终执行结果和代码顺序执行的结果一致；但是多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。\n我们往往用下面的代码验证 volatile 禁止指令重排，如果多线程环境下，最后的输出结果不一定是我们想象到的 ，这时就要把两个变量都设置为 volatile。\npublic class ReSortSeqDemo &#123;\n\n    int a &#x3D; 0;\n    boolean flag &#x3D; false;\n\n    public void mehtod1()&#123;\n        a &#x3D; 1;\n        flag &#x3D; true;\n    &#125;\n\n    public void method2()&#123;\n        if(flag)&#123;\n            a &#x3D; a +1;\n            System.out.println(&quot;reorder value: &quot;+a);\n        &#125;\n    &#125;\n&#125;Copy to clipboardErrorCopied\n\nvolatile 实现禁止指令重排优化，从而避免了多线程环境下程序出现乱序执行的现象。\n还有一个我们最常见的多线程环境中 DCL(double-checked locking) 版本的单例模式中，就是使用了 volatile 禁止指令重排的特性。\npublic class Singleton &#123;\n\n    private static volatile Singleton instance;\n\n    private Singleton()&#123;&#125;\n    &#x2F;&#x2F; DCL\n    public static Singleton getInstance()&#123;\n        if(instance &#x3D;&#x3D;null)&#123;   &#x2F;&#x2F;第一次检查\n            synchronized (Singleton.class)&#123;\n                if(instance &#x3D;&#x3D; null)&#123;   &#x2F;&#x2F;第二次检查\n                    instance &#x3D; new Singleton();\n                &#125;\n            &#125;\n        &#125;\n        return instance;\n    &#125;\n&#125;Copy to clipboardErrorCopied\n\n因为有指令重排序的存在，双端检索机制也不一定是线程安全的。\nwhy ?\nBecause: instance = new Singleton(); 初始化对象的过程其实并不是一个原子的操作，它会分为三部分执行，\n\n给 instance 分配内存\n调用 instance 的构造函数来初始化对象\n将 instance 对象指向分配的内存空间（执行完这步 instance 就为非 null 了）\n\n步骤 2 和 3 不存在数据依赖关系，如果虚拟机存在指令重排序优化，则步骤 2和 3 的顺序是无法确定的。如果A线程率先进入同步代码块并先执行了 3 而没有执行 2，此时因为 instance 已经非 null。这时候线程 B 在第一次检查的时候，会发现 instance 已经是 非null 了，就将其返回使用，但是此时 instance 实际上还未初始化，自然就会出错。所以我们要限制实例对象的指令重排，用 volatile 修饰（JDK 5 之前使用了 volatile 的双检锁是有问题的）。\n\n4. 原理volatile 可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在 JVM 底层是基于内存屏障实现的。\n\n当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有多个CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中\n而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步，所以就不会有可见性问题\n对 volatile 变量进行写操作时，会在写操作后加一条 store 屏障指令，将工作内存中的共享变量刷新回主内存；\n对 volatile 变量进行读操作时，会在写操作后加一条 load 屏障指令，从主内存中读取共享变量；\n\n\n\n通过 hsdis 工具获取 JIT 编译器生成的汇编指令来看看对 volatile 进行写操作CPU会做什么事情，还是用上边的单例模式，可以看到\n\n（PS：具体的汇编指令对我这个 Javaer 太南了，但是 JVM 字节码我们可以认识，putstatic 的含义是给一个静态变量设置值，那这里的 putstatic instance ,而且是第 17 行代码，更加确定是给 instance 赋值了。果然像各种资料里说的，找到了 lock add1 据说还得翻阅。这里可以看下这两篇 https://www.jianshu.com/p/6ab7c3db13c3 、 https://www.cnblogs.com/xrq730/p/7048693.html ）\n有 volatile 修饰的共享变量进行写操作时会多出第二行汇编代码，该句代码的意思是对原值加零，其中相加指令addl前有 lock 修饰。通过查IA-32架构软件开发者手册可知，lock前缀的指令在多核处理器下会引发两件事情：\n\n将当前处理器缓存行的数据写回到系统内存\n这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效\n\n正是 lock 实现了 volatile 的「防止指令重排」「内存可见」的特性\n\n5. 使用场景您只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：\n\n对变量的写操作不依赖于当前值\n该变量没有包含在具有其他变量的不变式中\n\n其实就是在需要保证原子性的场景，不要使用 volatile。\n\n6. volatile 性能volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。\n引用《正确使用 volaitle 变量》一文中的话：\n很难做出准确、全面的评价，例如 “X 总是比 Y 快”，尤其是对 JVM 内在的操作而言。（例如，某些情况下 JVM 也许能够完全删除锁机制，这使得我们难以抽象地比较 volatile 和 synchronized 的开销。）就是说，在目前大多数的处理器架构上，volatile 读操作开销非常低 —— 几乎和非 volatile 读操作一样。而 volatile 写操作的开销要比非 volatile 写操作多很多，因为要保证可见性需要实现内存界定（Memory Fence），即便如此，volatile 的总开销仍然要比锁获取低。\nvolatile 操作不会像锁一样造成阻塞，因此，在能够安全使用 volatile 的情况下，volatile 可以提供一些优于锁的可伸缩特性。如果读操作的次数要远远超过写操作，与锁相比，volatile 变量通常能够减少同步的性能开销。\n","slug":"Volatile笔记","date":"2020-08-19T03:14:00.000Z","categories_index":"笔记","tags_index":"笔记","author_index":"Cao Wei"},{"id":"b045ec127f1b9010d29cd174aab9b9b9","title":"Java多线程知识（未完待续）","content":"Java多线程知识第一篇：基础篇第一章：进程与线程的基本概念1.1 线程和进程的一些概念进程的提出：由于批处理操作系统的指令运行方式仍然是串行的，内存中始终只有一个程序在运行，后面的程序需要等待前面的程序执行完成后才能开始执行，而前面的程序有时会由于I/O操作、网络等原因阻塞，所以批处理操作效率也不高。\n进程的概念：进程就是应用程序在内存中分配的空间，也就是正在运行的程序，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态。\n上下文切换：CPU为每个进程分配一个时间段，称作它的时间片。如果在时间片结束时进程还在运行，则暂停这个进程的运行，并且CPU分配给另一个进程。\n\n\n\n\n\n\n\n\n\n当进程暂停时，它会保存当前进程的状态（进程标识，进程使用的资源等），在下一次切换回来时根据之前保存的状态进行恢复，接着继续执行。\n进程让操作系统的并发成为了可能！\n线程的提出：虽然进程的出现，使得操作系统的性能大大提升，但是随着时间的推移，人们并不满足一个进程在一段时间只能做一件事情，如果一个进程有多个子任务时，只能逐个得执行这些子任务，很影响效率。\n线程的概念：让一个线程执行一个子任务，这样一个进程就包含了多个线程，每个线程负责一个单独的子任务。\n进程让操作系统的并发性成为了可能，而线程让进程的内部并发成为了可能。\n使用多线程的好处：\n\n进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，我们需要使用共享资源，这些资源在线程间的通信比较容易。\n进程是重量级的，而线程是轻量级的，故多线程方式的系统开销更小。\n\n进程和线程的区别：\n二者最本质的区别就是是否单独占有内存地址空间以及其他系统资源（比如I/O）\n\n进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。\n进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。\n进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。\n\n另外一个重要区别是，进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位 。\n1.2 上下文切换上下文切换（有时也称做进程切换或任务切换）是指 CPU 从一个进程（或线程）切换到另一个进程（或线程）。上下文是指某一时间点 CPU 寄存器和程序计数器的内容。\n\n\n\n\n\n\n\n\n\n寄存器是cpu内部的少量的速度很快的闪存，通常存储和访问计算过程的中间值提高计算机程序的运行速度。\n程序计数器是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体实现依赖于特定的系统。\n举例说明 线程A - B\n1.先挂起线程A，将其在cpu中的状态保存在内存中。\n2.在内存中检索下一个线程B的上下文并将其在 CPU 的寄存器中恢复,执行B线程。\n3.当B执行完，根据程序计数器中指向的位置恢复线程A。\nCPU通过为每个线程分配CPU时间片来实现多线程机制。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。\n但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。\n上下文切换通常是计算密集型的，意味着此操作会消耗大量的 CPU 时间，故线程也不是越多越好。如何减少系统中上下文切换次数，是提升多线程性能的一个重点课题。\n第二章：Java多线程入门类和接口2.1 Thread类和Runnable接口JDk为我们提供了Thread类和Runnable接口实现自己的线程：\n\n继承Thread类，并重写run()方法\n实现Runnable接口的run()方法\n\n2.1.1 继承Thread类代码示例：\npublic class Demo &#123;\n    public static class MyThread extends Thread &#123;\n        @Override\n        public void run() &#123;\n            System.out.println(&quot;MyThread&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Thread myThread &#x3D; new MyThread();\n        myThread.start();\n    &#125;\n&#125;\n\n必须要调用start()方法以后，线程才算启动！\n\n\n\n\n\n\n\n\n\n我们调用start()方法之后，虚拟机会创建出一个线程，此时线程只是就绪状态，只有当前线程分配到CPU时间片以后，再调用run()方法，线程开始执行任务。\n不可以多次调用start() 方法，不然会报异常！\n2.1.2 实现Runnable接口Runnable接口是一个函数式接口：\n@FunctionalInterface\npublic interface Runnable &#123;\n    public abstract void run();\n&#125;\n\n这意味着可以使用函数式编程来简化代码：\npublic class Demo &#123;\n    public static class MyThread implements Runnable &#123;\n        @Override\n        public void run() &#123;\n            System.out.println(&quot;MyThread&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        new MyThread().run();\n\n        &#x2F;&#x2F; Java 8 函数式编程，可以省略MyThread类\n        new Thread(() -&gt; &#123;\n            System.out.println(&quot;Java 8 匿名内部类&quot;);\n        &#125;).start();\n    &#125;\n&#125;\n\n2.1.3 Thread类的构造方法Thread类是一个Runnable接口的实现类，我们来看看Thread类的源码。\n查看Thread类的构造方法，发现其实是简单调用一个私有的init方法来实现初始化。init的方法签名：\n&#x2F;&#x2F; Thread类源码 \n\n&#x2F;&#x2F; 片段1 - init方法\nprivate void init(ThreadGroup g, Runnable target, String name,\n                      long stackSize, AccessControlContext acc,\n                      boolean inheritThreadLocals)\n\n&#x2F;&#x2F; 片段2 - 构造函数调用init方法\npublic Thread(Runnable target) &#123;\n    init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);\n&#125;\n\n&#x2F;&#x2F; 片段3 - 使用在init方法里初始化AccessControlContext类型的私有属性\nthis.inheritedAccessControlContext &#x3D; \n    acc !&#x3D; null ? acc : AccessController.getContext();\n\n&#x2F;&#x2F; 片段4 - 两个对用于支持ThreadLocal的私有属性\nThreadLocal.ThreadLocalMap threadLocals &#x3D; null;\nThreadLocal.ThreadLocalMap inheritableThreadLocals &#x3D; null;\n\n我们挨个来解释一下init方法的这些参数：\n\ng：线程组，指定这个线程是在哪个线程组下；\n\ntarget：指定要执行的任务；\n\nname：线程的名字，多个线程的名字是可以重复的。如果不指定名字，见片段2；\n\nacc：见片段3，用于初始化私有变量inheritedAccessControlContext。\n\n\n\n\n\n\n\n\n\n这个变量有点神奇。它是一个私有变量，但是在Thread类里只有init方法对它进行初始化，在exit方法把它设为null。其它没有任何地方使用它。一般我们是不会使用它的，那什么时候会使用到这个变量呢？可以参考这个stackoverflow的问题：Restrict permissions to threads which execute third party software；\n\ninheritThreadLocals：可继承的ThreadLocal，见片段4，Thread类里面有两个私有属性来支持ThreadLocal，我们会在后面的章节介绍ThreadLocal的概念。\n\n\n实际情况下，我们大多是直接调用下面两个构造方法：\nThread(Runnable target)\nThread(Runnable target, String name)\n\n2.1.4 Thread类的几个常用方法\ncurrentThread()：静态方法，返回对当前正在执行的线程对象的引用；\nstart()：开始执行线程的方法，java虚拟机会调用线程内的run()方法；\nyield()：yield在英语里有放弃的意思，同样，这里的yield()指的是当前线程愿意让出对当前处理器的占用。这里需要注意的是，就算当前线程调用了yield()方法，程序在调度的时候，也还有可能继续运行这个线程的；\nsleep()：静态方法，使当前线程睡眠一段时间；\njoin()：使当前线程等待另一个线程执行完毕之后再继续执行，内部调用的是Object类的wait方法实现的；\n\n2.1.5 Thread类和Runnable接口的比较\n由于Java“单继承，多实现”的特性，Runnable接口使用起来比Thread更灵活。\nRunnable接口出现更符合面向对象，将线程单独进行对象的封装。\nRunnable接口出现，降低了线程对象和线程任务的耦合性。\n如果使用线程时不需要使用Thread类的诸多方法，显然使用Runnable接口更为轻量。\n\n所以，我们通常优先使用“实现Runnable接口”这种方式来自定义线程类。\n2.2 Callable、Future与FutureTask使用上述的两种方式实现多线程又一个弊端，就是run()方法没有返回值。\nJDK给我们提供了Callable接口与Future类为我们解决这个问题，这也是所谓的“异步”模型。\n2.2.1 Callable接口Callable接口和Runnable接口类似，也是一个函数式接口，不同之处在于前者的run()方法有返回值，并且支持泛型。\n@FunctionalInterface\npublic interface Callable&lt;V&gt; &#123;\n    V call() throws Exception;\n&#125;\n\nCallable接口一般是配合线程池工具ExcutorService使用的，这里只介绍ExecutorService可以使用submit方法来让一个Callable接口执行。它会返回一个Future，我们后续的程序可以通过这个Future的get方法得到结果。\n&#x2F;&#x2F; 自定义Callable\nclass Task implements Callable&lt;Integer&gt;&#123;\n    @Override\n    public Integer call() throws Exception &#123;\n        &#x2F;&#x2F; 模拟计算需要一秒\n        Thread.sleep(1000);\n        return 2;\n    &#125;\n    public static void main(String args[])&#123;\n        &#x2F;&#x2F; 使用\n        ExecutorService executor &#x3D; Executors.newCachedThreadPool();\n        Task task &#x3D; new Task();\n        Future&lt;Integer&gt; result &#x3D; executor.submit(task);\n        &#x2F;&#x2F; 注意调用get方法会阻塞当前线程，直到得到结果。\n        &#x2F;&#x2F; 所以实际编码中建议使用可以设置超时时间的重载get方法。\n        System.out.println(result.get()); \n    &#125;\n&#125;\n\n输出结果：\n2\n\n2.2.2 Future接口Future接口只有几个比较简单的方法：\npublic abstract interface Future&lt;V&gt; &#123;\n    public abstract boolean cancel(boolean paramBoolean);\n    public abstract boolean isCancelled();\n    public abstract boolean isDone();\n    public abstract V get() throws InterruptedException, ExecutionException;\n    public abstract V get(long paramLong, TimeUnit paramTimeUnit)\n            throws InterruptedException, ExecutionException, TimeoutException;\n&#125;\n\ncancel方法是试图取消一个线程的执行。\n注意是试图取消，并不一定能取消成功。因为任务可能已完成、已取消、或者一些其它因素不能取消，存在取消失败的可能。boolean类型的返回值是“是否取消成功”的意思。参数paramBoolean表示是否采用中断的方式取消线程执行。\n所以有时候，为了让任务有能够取消的功能，就使用Callable来代替Runnable。如果为了可取消性而使用 Future但又不提供可用的结果，则可以声明 Future&lt;?&gt;形式类型、并返回 null作为底层任务的结果。\n","slug":"多线程","date":"2020-08-05T08:41:00.000Z","categories_index":"并发编程","tags_index":"笔记,并发编程","author_index":"Cao Wei"},{"id":"a38aadce42dddbcde7f41fcb5e12b8a9","title":"单例模式详解","content":"单例模式一、什么是单例模式\n单例类只能有一个实例\n必须自行创建自己的唯一实例\n向所有其他对象提供这一实例\n\n二、单例模式的分类饿汉式：在类加载时候就创建单例（不管是否需要使用，都会先创建）\n懒汉式：在需要使用实例的时候才创建\n三、代码实现单例模式的核心思想：\n\n定义私有静态对象作为该类的唯一实例obj。\n私有化构造函数，保证用户不可以直接通过构造函数创建该类实例，或直接访问该类实例。\n定义一个公有的getInstance()方法去获得该类的唯一单例obj。\n\n饿汉式：方法一静态常量：将唯一实例instance设置为静态常量\npublic class Singleton1 &#123;\n    private static final Singleton1 INSTANCE &#x3D; new Singleton1();\n    private Singleton1() &#123;\n        System.out.println(&quot;单例模式懒汉式(静态常量)——我被new出来了&quot;);\n    &#125;\n    public static Singleton1 getInstance() &#123;\n        return INSTANCE;\n    &#125;\n&#125;\n\n特点：多线程下可以保证是唯一实例，但是造成了资源浪费，因为有时候我们可能不需要这个实例\n方法二静态代码块：将类的实例化放在静态代码块中\npublic class Singleton2 &#123;\n    private static Singleton2 instance;\n    static &#123;\n        instance &#x3D; new Singleton2();\n    &#125;\n    private Singleton2() &#123;\n        System.out.println(&quot;单例模式懒汉式(静态代码块)——我被new出来了&quot;);\n    &#125;\n\n    public static Singleton2 getInstance() &#123;\n        return instance;\n    &#125;\n&#125;\n\n特点：与方法一相同\n方法三静态内部类：\npublic class Singleton3 &#123;\n    private Singleton3() &#123;\n        System.out.println(&quot;单例模式懒汉式(静态内部类)——我被new出来了&quot;);\n    &#125;\n    public static class SingletonInstance &#123;\n        private static final Singleton3 instance &#x3D; new Singleton3();\n    &#125;\n    public static Singleton3 getInstance() &#123;\n        return SingletonInstance.instance;\n    &#125;\n&#125;\n\n特点：Singleton3在加载的时候不会被实例化，而是在需要实例化时（调用getInstance()）,才会装载静态内部类，从而完成Singleton2的实例化。多线程下可以实现单例。\n懒汉式：方法一只判断一次+不加任何同步锁 多线程下不能实现单例，错误示范！\npublic class Singleton4 &#123;\n    private static Singleton4 instance &#x3D; null;\n    private Singleton4() &#123;\n        System.out.println(&quot;实例被new出来了&quot;);\n    &#125;\n    public static Singleton4 getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new Singleton4();\n        &#125;\n        return instance;\n    &#125;\n&#125;\n\n该方式不能保证高并发下的单个实例：比如线程1运行到if (instance == null)这行代码，还没来得及运行下一行创建实例的代码，此时线程2获得CPU时间片，恰好也运行到这个判断条件，就同样得到一个true结果，因此出现了两个实例！！！\n方法二用synchronized对getInstance()方法加锁，可以实现单例\npublic class Singleton5 &#123;\n    private static Singleton5 instance &#x3D; null;\n    private Singleton5() &#123;\n        System.out.println(&quot;实例被new出来了&quot;);\n    &#125;\n    public static synchronized Singleton5 getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new Singleton5();\n        &#125;\n        return instance;\n    &#125;\n&#125;\n\n缺点：这样给整个方法都加上了同步锁，即每次想得到一次单例都会给此方法加锁，这样使线程之间退化成串行化的执行。上面方法效率太低，我希望只在该方法执行第一次实例化的时候加锁，如果该单例已被new出，则不进入同步区域，直接返回即可。\n方法三用synchronized对类加同步锁+双重检查  这个看测试结果似乎能实现单例，但其实没有volatile修饰的obj实例的这个类也是一个错误方法！\npublic class Singleton6 &#123;\n    private static Singleton6 instance &#x3D; null;\n    private Singleton6() &#123;\n        System.out.println(&quot;实例被new出来了&quot;);\n    &#125;\n    public static Singleton6 getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            synchronized (Singleton6.class) &#123;\n                if (instance &#x3D;&#x3D; null) &#123;\n                    instance &#x3D; new Singleton6(); &#x2F;&#x2F;error\n                &#125;\n            &#125;\n        &#125;\n        return instance;\n    &#125;\n&#125;\n\n双重检查锁：\n第一次检查instance是否被初始化（不去获得锁，只是查看是否满足加锁的条件而言），若已被初始化则返回。\n第二次检查instance查看在加锁阻塞期间，是否已经有其他线程先一步对instance做了初始化。\n这样看来似乎单例没问题呀，但其实这里有一个隐患，对构造函数来说，编译器为了优化进行指令重排序：\n\n\n\n\n\n\n\n\n\n实例化对象的那行代码（注释为为error的那行），实际上可以分解成以下三个步骤：\n\n分配内存空间\n初始化对象\n将对象指向刚分配的内存空间\n\n但是有些编译器为了性能的原因，可能会将第二步和第三步进行重排序，顺序就成了：\n\n分配内存空间\n将对象指向刚分配的内存空间\n初始化对象\n\n因此整个过程可能会变成如下场景：\n\n\n\nStep\nThread A\nThread B\n\n\n\nS1\n检查到对象instance为空\n\n\n\nS2\n获取类的同步锁\n\n\n\nS3\n再次检查到instance为空\n\n\n\nS4\n为instance分配内存空间\n\n\n\nS5\n将instance指向刚分配的内存空间\n\n\n\nS6\n\n检查到对象instance不为空\n\n\nS7\n\n访问并返回instance（此时对象还未初始化，得到一个初始化未完成的对象）\n\n\nS8\n初始化instance\n\n\n\n表格中，S7时刻线程B对instance的访问，访问的是一个初始化未完成的对象，发生错误。 \n方法四双重校验+volatile\n双重校验+volatile 与上一个类不同的是，该类中对这个单例obj加了volatile关键字。这个关键字的作用是：使用了volatile关键字后，重排序被禁止，所有的写（write）操作都将发生在读（read）操作之前。在volatile和synchronized两端线程安全的保护下，保证多线程下单例的创建。\npublic class Singleton7 &#123;\n    private static volatile Singleton7 instance &#x3D; null;\n    private Singleton7() &#123;\n        System.out.println(&quot;实例被new出来了&quot;);\n    &#125;\n    public static Singleton7 getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            synchronized (Singleton7.class) &#123;\n                if (instance &#x3D;&#x3D; null) &#123;\n                    instance &#x3D; new Singleton7();\n                &#125;\n            &#125;\n        &#125;\n        return instance;\n    &#125;\n&#125;\n\n该方式是最完善的方式，面试的时候被问起直接上这种方式！\n四、单例模式的使用场景\n需要频繁的进行创建和销毁的对象；\n创建对象时耗时过多或耗费资源过多，但又经常用到的对象；\n工具类对象；\n频繁访问数据库或文件的对象。\n\n优点：该类只存在一个对象，节省了系统资源（省去了对象的频繁创建与销毁），提高了系统性能。\n缺点：当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new，可能会给其他开发人员造成困扰，特别是看不到源码的时候。例如本文中要创建一个单例类的实例时，你要知道getInstance（）这个函数名。\n","slug":"单例模式","date":"2020-07-28T09:02:00.000Z","categories_index":"设计模式","tags_index":"笔记,设计模式","author_index":"Cao Wei"},{"id":"bc120f0c5b799be5c628de13faac0671","title":"顺序队列和循环队列","content":"什么是队列对于数组来说，我们可以通过下标值拿到每一个具体的元素。但是有些时候我们需要一种限制存取顺序的数据结构，此时队列和栈便派上了用场。\n队列与栈的不同之处在于，队列是先进先出（FIFO）而栈是后入先出（LIFO），其实队列二字“名副其实”，我们可以将其理解为日常生活中的排队：当我们在超市收银台结账时，肯定是排在前面的顾客先结账，然后依次是后面的顾客结账（不考虑某些人的插队行为）。\n\n如上图所示，队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。 删除（delete）操作也被称为出队（dequeue)。 你只能移除第一个元素。\n顺序队列顺序队列可以基于动态数组和指向头部的指针的方式实现的，是连续的一块内存空间。其结构如下图：\n\n\n按照上述，其实现也十分简单，下面给出一种实现\npublic class MyQueue &#123;\n    &#x2F;&#x2F;存储数据\n    private List&lt;Integer&gt; data;\n    &#x2F;&#x2F;指向队列头部数据的指针\n    private int p_start;\n\n    public MyQueue() &#123;\n        this.data &#x3D; data &#x3D; new ArrayList&lt;Integer&gt;();\n        this.p_start &#x3D; 0;\n    &#125;\n\n    &#x2F;&#x2F;数据入列\n    public Boolean enQueue(int x)&#123;\n        data.add(x);\n        return true;\n    &#125;\n\n    &#x2F;&#x2F;数据出列\n    public Boolean deQueue()&#123;\n        if (isEmpty())&#123;\n            return false;\n        &#125;\n        p_start++;\n        return true;\n    &#125;\n\n    &#x2F;&#x2F;获取队列头的元素\n    public int getFront()&#123;\n        return data.get(p_start);\n    &#125;\n\n    &#x2F;&#x2F;判断是否为空\n    public Boolean isEmpty()&#123;\n        return p_start &gt;&#x3D; data.size();\n    &#125;\n\n    public static void main(String[] args) &#123;\n        MyQueue myQueue &#x3D; new MyQueue();\n        myQueue.enQueue(1);\n        myQueue.enQueue(2);\n        myQueue.enQueue(3);\n        myQueue.enQueue(4);\n        System.out.println(myQueue.getFront());\n        myQueue.deQueue();\n        System.out.println(myQueue.getFront());\n    &#125;\n&#125;\n\n顺序队列的缺点顺序队列的实现确实很简单，但是随着我们对一部分数据进行出队操作后，头部指针会渐渐后移，而头部指针前面的空间虽然已经被释放，但是它既不能被回收也不能被再次利用，造成了很大的空间浪费，我们当然可以每次队列满了以后将数据总体前移（如下图所示），这样虽然保证了空间不会被浪费，但是时间复杂度从O(1)变成了O(n)，也是非常大的性能开销。\n\n\n循环队列上述通过数组来实现的队列，我们虽然进行了优化，但是当有空间无法利用时时，还是会进行一次数据搬移，性能也会收到影响，能否避免数据呢？答案是肯定的，看一下循环队列的解决思路。\n循环队列就相当于一个圆环，数组可以想象成一条直线，我们把这条直线掰成一个圆环，就是循环队列，为了更形象的表示，可以看下图所示：\n\n循环队列中，我们需要两个指针，即head和tail分别指向队列的头和尾，当队列初始化时，head和tail都指向索引为0的位置。如果有数据入队，tail则后移一次，如果有数据出队，head则后移一次。\n但是上述的过程会出现一系列问题：\n\n如果数组的大小为4，当tail指向3时，怎样让下一次入队时tail指向0（假设0位置可以插入）而不是指向4（指向4就造成数组下标越界了）？\n当队列空或者满时，都存在head=tail，如何判断队列到底是空还是满？\n\n下面我们逐个解决\n\n关于指针越界的问题其实很简单，我们只需要每次在对tail或者head加1时进行一次取余操作，即\n(head + 1) % size;\n关于判断队列空和满状态的问题，我的思路是：舍弃一个存储空间。也就是说如果tail的下一个是head，那么现在tail指向的空间就不再存储数据。如果是队列不断进行出队操作，head渐渐“追上”tail时，会出现head=tail的情况，此时队列为空。\n\n\n总结一下：舍弃队列的最后一个存储空间，那么队列为空的标志是(tail + 1) % size = head，队列为满的标志是head = tail。\n为了满足用户的需求，在实现时我们必须保证用户请求的空间数，因此具体到代码实现上，我们初始化队列时就初始化一个比用户申请空间大1的数组。下面给出一种代码实现：\npublic class MyCircularQueue &#123;\n\n    private int[] data;\n    private int head;\n    private int tail;\n    private int size;\n\n    &#x2F;**\n     * Initialize your data structure here. Set the size of the queue to be k.\n     *&#x2F;\n    public MyCircularQueue(int k) &#123;\n        &#x2F;&#x2F;初始化一个比用户要求大1的数组\n        size &#x3D; k+1;\n        data &#x3D; new int[size];\n        head &#x3D; 0;\n        tail &#x3D; 0;\n    &#125;\n\n    &#x2F;**\n     * Insert an element into the circular queue. Return true if the operation is successful.\n     *&#x2F;\n    public boolean enQueue(int value) &#123;\n        if (isFull()) &#123;\n            return false;\n        &#125;\n        data[tail] &#x3D; value;\n        tail &#x3D; (tail + 1) % size;\n        return true;\n    &#125;\n\n    &#x2F;**\n     * Delete an element from the circular queue. Return true if the operation is successful.\n     *&#x2F;\n    public boolean deQueue() &#123;\n        if (isEmpty())&#123;\n            return false;\n        &#125;\n        head &#x3D; (head + 1) % size;\n        return true;\n    &#125;\n\n    &#x2F;**\n     * Get the front item from the queue.\n     *&#x2F;\n    public int Front() &#123;\n        if (isEmpty())&#123;\n            return -1;\n        &#125;\n        return data[head];\n    &#125;\n\n    &#x2F;**\n     * Get the last item from the queue.\n     *&#x2F;\n    public int Rear() &#123;\n        if (isEmpty())&#123;\n            return -1;\n        &#125;\n        &#x2F;&#x2F;之所以要加上size是因为此处tail可能是0\n        return data[(tail - 1 + size) % size];\n    &#125;\n\n    &#x2F;**\n     * Checks whether the circular queue is empty or not.\n     *&#x2F;\n    public boolean isEmpty() &#123;\n        return head &#x3D;&#x3D; tail;\n    &#125;\n\n    &#x2F;**\n     * Checks whether the circular queue is full or not.\n     * 如果仅仅使用tail &#x3D;&#x3D; head来判断队列是否满，则无法判断到底是空还是满\n     * 因此要牺牲最后一个存储单元。即如果tail的下一个是head，就认为满了\n     *&#x2F;\n    public boolean isFull() &#123;\n        return (tail + 1) % size &#x3D;&#x3D; head;\n    &#125;\n\n&#125;\n\n\n队列的其他形式队列其实还有链式队列，无界队列，阻塞队列、并发队列等等，我们以后再聊！\n","slug":"普通队列和循环队列的Java实现","date":"2020-03-23T08:41:00.000Z","categories_index":"算法","tags_index":"笔记,算法","author_index":"Cao Wei"},{"id":"377b436afa644e00cf7f3b27b55ec3f4","title":"Vue组件基础","content":"Vue组件基础Vue的组件化思想组件化是Vue中很重要的思想：\n\n它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用\n任何的应用都会被抽象成一颗组件树\n\n\n组件化思想的应用：\n\n有了组件化的思想，我们在之后的开发中就要充分的利用它。\n尽可能的将页面拆分成一个个小的、可复用的组件。\n这样让我们的代码更加方便组织和管理，并且扩展性也更强。\n\n注册组件全局注册\nVue.component(‘组件名称’, { })     第1个参数是标签名称，第2个参数是一个选项对象\n全局组件注册后，任何vue实例都可以用\n\n&lt;div id&#x3D;&quot;example&quot;&gt;\n  &lt;!-- 2、 组件使用 组件名称 是以HTML标签的形式使用  --&gt;  \n  &lt;my-component&gt;&lt;&#x2F;my-component&gt;\n&lt;&#x2F;div&gt;\n&lt;script&gt;\n    &#x2F;&#x2F;   注册组件 \n    &#x2F;&#x2F; 1、 my-component 就是组件中自定义的标签名\n\tVue.component(&#39;my-component&#39;, &#123;\n      template: &#39;&lt;div&gt;A custom component!&lt;&#x2F;div&gt;&#39;\n    &#125;)\n\n    &#x2F;&#x2F; 创建根实例\n    new Vue(&#123;\n      el: &#39;#example&#39;\n    &#125;)\n\n&lt;&#x2F;script&gt;\n\n局部注册&lt;div id&#x3D;&quot;app&quot;&gt;\n      &lt;my-component&gt;&lt;&#x2F;my-component&gt;\n  &lt;&#x2F;div&gt;\n\n\n&lt;script&gt;\n    &#x2F;&#x2F; 定义组件的模板\n    var Child &#x3D; &#123;\n      template: &#39;&lt;div&gt;A custom component!&lt;&#x2F;div&gt;&#39;\n    &#125;\n    new Vue(&#123;\n      &#x2F;&#x2F;局部注册组件  \n      components: &#123;\n        &#x2F;&#x2F; &lt;my-component&gt; 将只在父模板可用  一定要在实例上注册了才能在html文件中使用\n        &#39;my-component&#39;: Child\n      &#125;\n    &#125;)\n &lt;&#x2F;script&gt;\n\n局部注册的组件只能在注册它的Vue实例中使用\n组件注意事项\n组件参数data必须是一个函数，同时要求改函数返回一个对象\n组件模板必须是单个根元素，当需要写多个HTML标签时，需在最外层套一个div\n组件模板的内容可以是模板字符串\n组件可以使用多次\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n\t\t&lt;title&gt;&lt;&#x2F;title&gt;\n\t&lt;&#x2F;head&gt;\n\t&lt;body&gt;\n\t\t&lt;div id&#x3D;&quot;app&quot;&gt;\n\t\t\t&lt;cpn&gt;&lt;&#x2F;cpn&gt;\n\t\t\t&lt;cpn&gt;&lt;&#x2F;cpn&gt;\n\t\t\t&lt;cpn&gt;&lt;&#x2F;cpn&gt;\n\t\t&lt;&#x2F;div&gt;\n\t\t&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n\t\t&lt;script&gt;\n\t\t\tVue.component(&#39;cpn&#39;, &#123;\n\t\t\t\ttemplate: &#39;&lt;button @click&#x3D;&quot;handle&quot;&gt;点击了&#123;&#123;counter&#125;&#125;次&lt;&#x2F;button&gt;&#39;,\n\t\t\t\tdata() &#123;\n\t\t\t\t\treturn &#123;\n\t\t\t\t\t\tcounter: 0\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;,\n\t\t\t\tmethods:&#123;\n\t\t\t\t\thandle() &#123;\n\t\t\t\t\t\tthis.counter++;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;)\n\t\t  const app &#x3D; new Vue(&#123;\n\t\t  el: &quot;#app&quot;,\n\t\t    data: &#123;\n\t\t\n\t\t    &#125;\n\t\t  &#125;);\n\t\t&lt;&#x2F;script&gt;\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n如上的代码中，名为cpn的组件被使用了三次，从运行效果可以看出，每个组件的counter变量是独立的\n\n模板的分离写法上述注册组件的方法，我们将template模板放在了注册组件的内部，这样做会带来两个坏处\n\n没有代码补全，撰写模板的过程更麻烦\n代码看起来更加凌乱\n\n因此一般我们会采用模板的分离写法，nVue提供了两种方案来定义HTML模块内容：\n\n使用&lt;script&gt;标签\n\n使用&lt;template&gt;标签\n\n\n\n\n组件之间的通信父组件向子组件传值\n父组件发送的形式是以属性的形式绑定值到子组件身上。\n然后子组件用属性props接收\n在props中使用驼峰形式，模板中需要使用短横线的形式，字符串形式的模板中没有这个限制\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n\t\t&lt;title&gt;Title&lt;&#x2F;title&gt;\n\t&lt;&#x2F;head&gt;\n\t&lt;body&gt;\n\t\t&lt;div id&#x3D;&quot;app&quot;&gt;\n\t\t\t&lt;cpn :c-movies&#x3D;&quot;movies&quot; :c-message&#x3D;&quot;message&quot;&gt;&lt;&#x2F;cpn&gt;\n\t\t&lt;&#x2F;div&gt;\n\t\t&lt;template id&#x3D;&quot;cpn&quot;&gt;\n\t\t\t&lt;div&gt;\n\t\t\t\t&lt;h2&gt;&#123;&#123;cMessage&#125;&#125;&lt;&#x2F;h2&gt;\n\t\t\t\t&lt;div&gt;\n\t\t\t\t\t&lt;ul&gt;\n\t\t\t\t\t\t&lt;li v-for&#x3D;&quot;item in cMovies&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt;\n\t\t\t\t\t&lt;&#x2F;ul&gt;\n\t\t\t\t&lt;&#x2F;div&gt;\n\t\t\t&lt;&#x2F;div&gt;\n\t\t&lt;&#x2F;template&gt;\n\t\t&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n\t\t&lt;script&gt;\n\t\t\tconst app &#x3D; new Vue(&#123;\n\t\t\t\tel: &quot;#app&quot;,\n\t\t\t\tdata: &#123;\n\t\t\t\t\tmessage: &#39;你好啊&#39;,\n\t\t\t\t\tmovies: [&#39;星际穿越&#39;, &#39;火星救援&#39;, &#39;星际迷航&#39;, &#39;星球大战&#39;]\n\t\t\t\t&#125;,\n\t\t\t\tcomponents: &#123;\n\t\t\t\t\tcpn: &#123;\n\t\t\t\t\t\ttemplate: &#39;#cpn&#39;,\n\t\t\t\t\t\tdata() &#123;\n\t\t\t\t\t\t\treturn &#123;\n\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t&#125;,\n\t\t\t\t\t\tmethods: &#123;\n\n\t\t\t\t\t\t&#125;,\n\t\t\t\t\t\tprops: &#123;\n\t\t\t\t\t\t\tcMovies: &#123;\n\t\t\t\t\t\t\t\ttype: Array,\n\t\t\t\t\t\t\t\tdefault () &#123;\n\t\t\t\t\t\t\t\t\treturn [&#39;随便什么电影&#39;]\n\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t&#125;,\n\t\t\t\t\t\t\tcMessage: &#123;\n\t\t\t\t\t\t\t\ttype: String,\n\t\t\t\t\t\t\t\tdefault: &#39;aaaaaa&#39;\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;,\n\t\t\t&#125;);\n\t\t&lt;&#x2F;script&gt;\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n上面的代码中，props属性采用的是对象写法，好处就是可以进行类型校验，默认值设置等操作，而另外的数组写法则不能进行这些操作：\nprops: [&#39;cMovies&#39;, &#39;cMessage&#39;]\n\n子组件向父组件传值\n子组件用$emit()触发事件\n$emit()  第一个参数为自定义的事件名称     第二个参数为需要传递的数据\n父组件用v-on 监听子组件的事件\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n\t\t&lt;title&gt;&lt;&#x2F;title&gt;\n\t&lt;&#x2F;head&gt;\n\t&lt;body&gt;\n\t\t &lt;div id&#x3D;&quot;app&quot;&gt;\n\t\t    &lt;div :style&#x3D;&#39;&#123;fontSize: fontSize + &quot;px&quot;&#125;&#39;&gt;&#123;&#123;pmsg&#125;&#125;&lt;&#x2F;div&gt;\n\t\t     &lt;!-- 父组件用v-on 监听子组件的事件\n\t\t\t\t这里 enlarge-text  是从 $emit 中的第一个参数对应   handle 为对应的事件处理函数\t\n\t\t\t--&gt;\t\n\t\t    &lt;menu-item :parr&#x3D;&#39;parr&#39; @enlarge-text&#x3D;&#39;handle($event)&#39;&gt;&lt;&#x2F;menu-item&gt;\n\t\t  &lt;&#x2F;div&gt;\n\t\t\t&lt;template id&#x3D;&quot;cpn&quot;&gt;\n\t\t\t\t&lt;div&gt;\n\t\t\t\t    &lt;ul&gt;\n\t\t\t\t      &lt;li :key&#x3D;&#39;index&#39; v-for&#x3D;&#39;(item,index) in parr&#39;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt;\n\t\t\t\t    &lt;&#x2F;ul&gt;\n\t\t\t\t\t\t&lt;!-- 子组件用$emit()触发事件\n\t\t\t\t\t\t第一个参数为 自定义的事件名称   第二个参数为需要传递的数据 --&gt;  \n\t\t\t\t    &lt;button @click&#x3D;&#39;$emit(&quot;enlarge-text&quot;, 5)&#39;&gt;扩大父组件中字体大小&lt;&#x2F;button&gt;\n\t\t\t\t    &lt;button @click&#x3D;&#39;$emit(&quot;enlarge-text&quot;, 10)&#39;&gt;扩大父组件中字体大小&lt;&#x2F;button&gt;\n\t\t\t\t  &lt;&#x2F;div&gt;\n\t\t\t&lt;&#x2F;template&gt;\n\t\t  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n\t\t  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n\t\t    var vm &#x3D; new Vue(&#123;\n\t\t      el: &#39;#app&#39;,\n\t\t      data: &#123;\n\t\t        pmsg: &#39;父组件中内容&#39;,\n\t\t        parr: [&#39;apple&#39;,&#39;orange&#39;,&#39;banana&#39;],\n\t\t        fontSize: 10\n\t\t      &#125;,\n\t\t      methods: &#123;\n\t\t        handle: function(val)&#123;\n\t\t          &#x2F;&#x2F; 扩大字体大小\n\t\t          this.fontSize +&#x3D; val;\n\t\t        &#125;\n\t\t      &#125;,\n\t\t\t\t\tcomponents:&#123;\n\t\t\t\t\t\t&#39;menu-item&#39;: &#123;\n\t\t\t\t\t\t\tprops: [&#39;parr&#39;],\n\t\t\t\t\t\t\ttemplate: &#39;#cpn&#39;\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t    &#125;);\n\t\t  &lt;&#x2F;script&gt;\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n兄弟间的传值\n兄弟之间传递数据需要借助于事件中心，通过事件中心传递数据   \n提供事件中心    var hub = new Vue()\n\n\n传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据)\n接收数据方，通过mounted(){} 钩子中  触发hub.$on()方法名\n销毁事件 通过hub.$off()方法名销毁之后无法进行传递数据\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n\t\t&lt;title&gt;&lt;&#x2F;title&gt;\n\t&lt;&#x2F;head&gt;\n\t&lt;body&gt;\n\t\t &lt;div id&#x3D;&quot;app&quot;&gt;\n\t\t    &lt;div&gt;父组件&lt;&#x2F;div&gt;\n\t\t    &lt;div&gt;\n\t\t      &lt;button @click&#x3D;&#39;handle&#39;&gt;销毁事件&lt;&#x2F;button&gt;\n\t\t    &lt;&#x2F;div&gt;\n\t\t    &lt;test-tom&gt;&lt;&#x2F;test-tom&gt;\n\t\t    &lt;test-jerry&gt;&lt;&#x2F;test-jerry&gt;\n\t\t  &lt;&#x2F;div&gt;\n\t\t  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n\t\t  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n\t\t    &#x2F;*\n\t\t      兄弟组件之间数据传递\n\t\t    *&#x2F;\n\t\t    &#x2F;&#x2F;1、 提供事件中心\n\t\t    var hub &#x3D; new Vue();\n\t\t\n\t\t    Vue.component(&#39;test-tom&#39;, &#123;\n\t\t      data: function()&#123;\n\t\t        return &#123;\n\t\t          num: 0\n\t\t        &#125;\n\t\t      &#125;,\n\t\t      template: &#96;\n\t\t        &lt;div&gt;\n\t\t          &lt;div&gt;TOM:&#123;&#123;num&#125;&#125;&lt;&#x2F;div&gt;\n\t\t          &lt;div&gt;\n\t\t            &lt;button @click&#x3D;&#39;handle&#39;&gt;点击&lt;&#x2F;button&gt;\n\t\t          &lt;&#x2F;div&gt;\n\t\t        &lt;&#x2F;div&gt;\n\t\t      &#96;,\n\t\t      methods: &#123;\n\t\t        handle: function()&#123;\n\t\t          &#x2F;&#x2F;2、传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据)   触发兄弟组件的事件\n\t\t          hub.$emit(&#39;jerry-event&#39;, 2);\n\t\t        &#125;\n\t\t      &#125;,\n\t\t      mounted: function() &#123;\n\t\t       &#x2F;&#x2F; 3、接收数据方，通过mounted()&#123;&#125; 钩子中  触发hub.$on(方法名\n\t\t        hub.$on(&#39;tom-event&#39;, (val) &#x3D;&gt; &#123;\n\t\t          this.num +&#x3D; val;\n\t\t        &#125;);\n\t\t      &#125;\n\t\t    &#125;);\n\t\t    Vue.component(&#39;test-jerry&#39;, &#123;\n\t\t      data: function()&#123;\n\t\t        return &#123;\n\t\t          num: 0\n\t\t        &#125;\n\t\t      &#125;,\n\t\t      template: &#96;\n\t\t        &lt;div&gt;\n\t\t          &lt;div&gt;JERRY:&#123;&#123;num&#125;&#125;&lt;&#x2F;div&gt;\n\t\t          &lt;div&gt;\n\t\t            &lt;button @click&#x3D;&#39;handle&#39;&gt;点击&lt;&#x2F;button&gt;\n\t\t          &lt;&#x2F;div&gt;\n\t\t        &lt;&#x2F;div&gt;\n\t\t      &#96;,\n\t\t      methods: &#123;\n\t\t        handle: function()&#123;\n\t\t          &#x2F;&#x2F;2、传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据)   触发兄弟组件的事件\n\t\t          hub.$emit(&#39;tom-event&#39;, 1);\n\t\t        &#125;\n\t\t      &#125;,\n\t\t      mounted: function() &#123;\n\t\t        &#x2F;&#x2F; 3、接收数据方，通过mounted()&#123;&#125; 钩子中  触发hub.$on()方法名\n\t\t        hub.$on(&#39;jerry-event&#39;, (val) &#x3D;&gt; &#123;\n\t\t          this.num +&#x3D; val;\n\t\t        &#125;);\n\t\t      &#125;\n\t\t    &#125;);\n\t\t    var vm &#x3D; new Vue(&#123;\n\t\t      el: &#39;#app&#39;,\n\t\t      data: &#123;\n\t\t        \n\t\t      &#125;,\n\t\t      methods: &#123;\n\t\t        handle: function()&#123;\n\t\t          &#x2F;&#x2F;4、销毁事件 通过hub.$off()方法名销毁之后无法进行传递数据  \n\t\t          hub.$off(&#39;tom-event&#39;);\n\t\t          hub.$off(&#39;jerry-event&#39;);\n\t\t        &#125;\n\t\t      &#125;\n\t\t    &#125;);\n\t\t  &lt;&#x2F;script&gt;\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n组件插槽匿名插槽\n组件最大的特性就是复用性，而插槽作为组件的扩展大大提高了组件的可复用能力\n\n在vue组件的模板中，可用&lt;slot&gt;&lt;/slot&gt;添加一个插槽，插槽内的内容是默认值，当没有被覆盖时，将显示默认值\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n\t\t&lt;title&gt;&lt;&#x2F;title&gt;\n\t&lt;&#x2F;head&gt;\n\t&lt;body&gt;\n\t\t&lt;div id&#x3D;&quot;app&quot;&gt;\n\t\t\t&lt;!-- 此处组件标签内没有其他内容，因此显示默认内容 --&gt;\n\t\t\t&lt;cpn&gt;&lt;&#x2F;cpn&gt;\n\t\t\t&lt;!-- 此处利用span标签覆盖了插槽的默认内容 --&gt;\n\t\t\t&lt;cpn&gt;&lt;span&gt;这里是一些文字&lt;&#x2F;span&gt;&lt;&#x2F;cpn&gt;\n\t\t\t&lt;!-- 组件标签里的所有内容都会作为插槽内容显示，因此此处的三个标签都会显示 --&gt;\n\t\t\t&lt;cpn&gt;\n\t\t\t\t&lt;b&gt;加粗文字&lt;&#x2F;b&gt;\n\t\t\t\t&lt;i&gt;斜体文字&lt;&#x2F;i&gt;\n\t\t\t\t&lt;span&gt;这里是一些文字&lt;&#x2F;span&gt;\n\t\t\t&lt;&#x2F;cpn&gt;\n\t\t&lt;&#x2F;div&gt;\n\t\t&lt;template id&#x3D;&quot;cpn&quot;&gt;\n\t\t\t&lt;div&gt;\n\t\t\t\t&lt;h2&gt;我是组件标题&lt;&#x2F;h2&gt;\n\t\t\t\t&lt;p&gt;我是组件的文本内容&lt;&#x2F;p&gt;\n\t\t\t\t&lt;slot&gt;&lt;button type&#x3D;&quot;button&quot;&gt;这是按钮&lt;&#x2F;button&gt;&lt;&#x2F;slot&gt;\n\t\t\t&lt;&#x2F;div&gt;\n\t\t&lt;&#x2F;template&gt;\n\t\t&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n\t\t&lt;script&gt;\n\t\t\tconst app &#x3D; new Vue(&#123;\n\t\t\t\tel: &#39;#app&#39;,\n\t\t\t\tdata: &#123;\n\t\t\t\t\t\n\t\t\t\t&#125;,\n\t\t\t\tcomponents:&#123;\n\t\t\t\t\tcpn: &#123;\n\t\t\t\t\t\ttemplate:&#39;#cpn&#39;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;)\n\t\t&lt;&#x2F;script&gt;\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n具名插槽\n当有多个插槽时，我们要想覆盖特定的某个插槽就必须使用名字，这就是具名插槽\n使用 &lt;slot&gt; 中的 “name” 属性绑定元素\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n\t\t&lt;title&gt;&lt;&#x2F;title&gt;\n\t&lt;&#x2F;head&gt;\n\t&lt;body&gt;\n\t\t&lt;div id&#x3D;&quot;app&quot;&gt;\n\t\t\t&lt;cpn&gt;\n\t\t\t\t&lt;button type&#x3D;&quot;button&quot; slot&#x3D;&quot;left&quot;&gt;按钮&lt;&#x2F;button&gt;\n\t\t\t\t&lt;span slot&#x3D;&quot;center&quot;&gt;&lt;b&gt;这是中间的标题&lt;&#x2F;b&gt;&lt;&#x2F;span&gt;\n\t\t\t\t&lt;a href&#x3D;&quot;&quot; slot&#x3D;&quot;right&quot;&gt;一个链接&lt;&#x2F;a&gt;\n\t\t\t&lt;&#x2F;cpn&gt;\n\t\t&lt;&#x2F;div&gt;\n\t\t&lt;template id&#x3D;&quot;cpn&quot;&gt;\n\t\t\t&lt;div&gt;\n\t\t\t\t&lt;slot name&#x3D;&quot;left&quot;&gt;&lt;span&gt;左边&lt;&#x2F;span&gt;&lt;&#x2F;slot&gt;\n\t\t\t\t&lt;slot name&#x3D;&quot;center&quot;&gt;&lt;span&gt;中间&lt;&#x2F;span&gt;&lt;&#x2F;slot&gt;\n\t\t\t\t&lt;slot name&#x3D;&quot;right&quot;&gt;&lt;span&gt;右边&lt;&#x2F;span&gt;&lt;&#x2F;slot&gt;\n\t\t\t&lt;&#x2F;div&gt;\n\t\t&lt;&#x2F;template&gt;\n\t\t&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n\t\t&lt;script&gt;\n\t\t\tconst app &#x3D; new Vue(&#123;\n\t\t\t\tel: &#39;#app&#39;,\n\t\t\t\tdata: &#123;\n\t\t\t\t\t\n\t\t\t\t&#125;,\n\t\t\t\tcomponents:&#123;\n\t\t\t\t\tcpn: &#123;\n\t\t\t\t\t\ttemplate:&#39;#cpn&#39;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;)\n\t\t&lt;&#x2F;script&gt;\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n作用域插槽\n父组件对子组件加工处理\n既可以复用子组件的slot，又可以使slot内容不一致\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n\t\t&lt;title&gt;&lt;&#x2F;title&gt;\n\t&lt;&#x2F;head&gt;\n\t&lt;body&gt;\n\t\t&lt;div id&#x3D;&quot;app&quot;&gt;\n\t\t\t&lt;!-- 默认是无序列表 --&gt;\n\t\t\t&lt;cpn&gt;&lt;&#x2F;cpn&gt;\n\t\t\t&lt;!-- 此处将内容改为每个元素中间用“-”连接 --&gt;\n\t\t\t&lt;cpn&gt;\n\t\t\t\t&lt;template v-slot&#x3D;&quot;slot&quot;&gt;\n\t\t\t\t\t&lt;span v-for&#x3D;&quot;item in slot.data&quot;&gt;&#123;&#123;item&#125;&#125; - &lt;&#x2F;span&gt;\n\t\t\t\t&lt;&#x2F;template&gt;\n\t\t\t&lt;&#x2F;cpn&gt;\n\t\t\t&lt;!-- 此处将内容改为每个元素中间用“*”连接 --&gt;\n\t\t\t&lt;cpn&gt;\n\t\t\t\t&lt;template v-slot&#x3D;&quot;slot&quot;&gt;\n\t\t\t\t\t&lt;span&gt;&#123;&#123;slot.data.join(&#39; * &#39;)&#125;&#125;&lt;&#x2F;span&gt;\n\t\t\t\t&lt;&#x2F;template&gt;\n\t\t\t&lt;&#x2F;cpn&gt;\n\t\t&lt;&#x2F;div&gt;\n\t\t&lt;template id&#x3D;&quot;cpn&quot;&gt;\n\t\t\t&lt;div&gt;\n\t\t\t\t&lt;slot :data&#x3D;&quot;items&quot;&gt;\n\t\t\t\t\t&lt;ul&gt;\n\t\t\t\t\t\t&lt;li v-for&#x3D;&quot;item in items&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt;\n\t\t\t\t\t&lt;&#x2F;ul&gt;\n\t\t\t\t&lt;&#x2F;slot&gt;\n\t\t\t&lt;&#x2F;div&gt;\n\t\t&lt;&#x2F;template&gt;\n\t\t&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n\t\t&lt;script&gt;\n\t\t\tconst app &#x3D; new Vue(&#123;\n\t\t\t\tel: &#39;#app&#39;,\n\t\t\t\tdata: &#123;\n\t\t\t\t\t\n\t\t\t\t&#125;,\n\t\t\t\tcomponents:&#123;\n\t\t\t\t\tcpn: &#123;\n\t\t\t\t\t\ttemplate:&#39;#cpn&#39;,\n\t\t\t\t\t\tdata() &#123;\n\t\t\t\t\t\t\treturn &#123;\n\t\t\t\t\t\t\t\titems: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;]\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;)\n\t\t&lt;&#x2F;script&gt;\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n父子组件通信的练习在接下来的实例中，我将模拟在有网络请求的情况下，用户点击不同的分类tab时显示不通内容的案例。\n\n父组件首先模拟向后台请求数据，请求到数据后显示tab列表并显示默认的数据\n用户可以点击按钮，点击后子组件通知父组件模拟请求对应的数据\n父组件请求到数据后传给子组件并显示\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n\t\t&lt;title&gt;&lt;&#x2F;title&gt;\n\t&lt;&#x2F;head&gt;\n\t&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;\n\t\t.active&#123;\n\t\t  background-color: #00aaff;\n\t\t&#125;\n\t\t.btn&#123;\n\t\t\tmargin-right: 10px;\n\t\t\tborder: 0;\n\t\t\tborder-radius: 2px;\n\t\t\tpadding-left: 10px;\n\t\t\tpadding-right: 10px;\n\t\t\theight: 30px;\n\t\t&#125;\n\t&lt;&#x2F;style&gt;\n\t&lt;body&gt;\n\t\t&lt;div id&#x3D;&quot;app&quot;&gt;\n\t\t\t&lt;cpn :categories&#x3D;&#39;categories&#39; :items&#x3D;&#39;items&#39; @btnclick&#x3D;&#39;changeitems&#39;&gt;&lt;&#x2F;cpn&gt;\n\t\t&lt;&#x2F;div&gt;\n\t&lt;&#x2F;body&gt;\n\t&lt;template id&#x3D;&quot;cpn&quot;&gt;\n\t\t&lt;div&gt;\n\t\t\t&lt;button type&#x3D;&quot;button&quot; class&#x3D;&quot;btn&quot; v-for&#x3D;&quot;(category, index) in categories&quot; \n\t\t\t@click&#x3D;&quot;btnclick(category, index)&quot; :class&#x3D;&quot;&#123;active: currentIndex &#x3D;&#x3D; index&#125;&quot;&gt;\n\t\t\t&#123;&#123;category.name&#125;&#125;\n\t\t\t&lt;&#x2F;button&gt;\n\t\t\t&lt;br&gt;\n\t\t\t&lt;ul&gt;\n\t\t\t\t&lt;li v-for&#x3D;&quot;item in items&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt;\n\t\t\t&lt;&#x2F;ui&gt;\n\t\t&lt;&#x2F;div&gt;\n\t&lt;&#x2F;template&gt;\n\t&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n\t&lt;script&gt;\n\t\tconst cpn &#x3D; &#123;\n\t\t\ttemplate: &#39;#cpn&#39;,\n\t\t\tprops: &#123;\n\t\t\t\titems: &#123;\n\t\t\t\t\ttype: Array,\n\t\t\t\t\tdefault() &#123;\n\t\t\t\t\t\treturn [&#39;无数据&#39;]\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;,\n\t\t\t\tcategories: &#123;\n\t\t\t\t\ttype: Array,\n\t\t\t\t\trequired: true\n\t\t\t\t&#125;\n\t\t\t&#125;,\n\t\t\tmethods: &#123;\n\t\t\t\tbtnclick(category, index)&#123;\n\t\t\t\t\t&#x2F;&#x2F;console.log(category);\n\t\t\t\t\tthis.currentIndex &#x3D; index;\n\t\t\t\t\tthis.$emit(&#39;btnclick&#39;, category);\n\t\t\t\t&#125;,\n\t\t\t&#125;,\n\t\t\tdata() &#123;\n\t\t\t\treturn &#123;\n\t\t\t\t\tcurrentIndex: 0\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;;\n\t\tconst app &#x3D; new Vue(&#123;\n\t\t\tel: &#39;#app&#39;,\n\t\t\tdata: &#123;\n\t\t\t\tcategories: [\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tid: &#39;movies&#39;,\n\t\t\t\t\t\tname: &#39;电影&#39;\n\t\t\t\t\t&#125;,\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tid: &#39;fruits&#39;,\n\t\t\t\t\t\tname: &#39;水果&#39;\n\t\t\t\t\t&#125;,\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tid: &#39;musics&#39;,\n\t\t\t\t\t\tname: &#39;音乐&#39;\n\t\t\t\t\t&#125;\n\t\t\t\t],\n\t\t\t\t&#x2F;&#x2F;ff\n\t\t\t\tlists: &#123;\n\t\t\t\t\tmovies: [&#39;星际穿越&#39;, &#39;火星救援&#39;, &#39;星际迷航&#39;, &#39;星球大战&#39;],\n\t\t\t\t\tfruits: [&#39;苹果&#39;, &#39;香蕉&#39;, &#39;草莓&#39;, &#39;鸭梨&#39;],\n\t\t\t\t\tmusics: [&#39;生命因你而火热&#39;, &#39;没有理想的人不伤心&#39;, &#39;你要跳舞吗&#39;]\n\t\t\t\t&#125;,\n\t\t\t\titems: []\n\t\t\t&#125;,\n\t\t\tcomponents: &#123;\n\t\t\t\tcpn\n\t\t\t&#125;,\n\t\t\tmounted() &#123;\n\t\t\t\t&#x2F;&#x2F;模拟网络请求和数据绑定\n\t\t\t\tthis.items &#x3D; this.lists.movies;\n\t\t\t&#125;,\n\t\t\tmethods: &#123;\n\t\t\t\tchangeitems(category) &#123;\n\t\t\t\t\t&#x2F;&#x2F;模拟网络请求和数据绑定\n\t\t\t\t\tthis.items &#x3D; this.lists[category.id];\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;)\n\t\t\n\t&lt;&#x2F;script&gt;\n&lt;&#x2F;html&gt;\n\n\n","slug":"Vue组件基础","date":"2020-03-13T09:34:00.000Z","categories_index":"Vue","tags_index":"笔记,Vue","author_index":"Cao Wei"},{"id":"8db6ae35b8dd147cb836bf37e9a80665","title":"Vue入门——基础语法","content":"Vue入门——基础语法Vue是什么？Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\nVue的优势对于前端开发人员来说，大家使用过很多的Javascript框架。比如原生的JavaScript,Jquery,angularjs和rectjs等。那么Vue与这些框架相比，它的优势体现在哪里？\n\nVue 只关注视图层， 采用自底向上增量开发的设计。Vue关注的是视图层，操作的对象是HTML元素。它是渐进的，没有强主张，你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用；也可以整个用它全家桶开发，当Angular用；还可以用它的视图，搭配你自己设计的整个下层用。你可以在底层数据逻辑的地方用OO和设计模式的那套理念，也可以函数式，都可以，它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。\nVue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。Vue.js 是一个更加灵活开放的解决方案。它允许你以希望的方式组织应用程序，而不是在任何时候都必须遵循 AngularJS 制定的规则，这让 Vue 能适用于各种项目.在 Vue 中指令和组件分得更清晰。指令只封装 DOM 操作，而组件代表一个自给自足的独立单元——有自己的视图和数据逻辑。\nVue 学习起来非常简单.在 API 与设计两方面上 Vue.js非常简单，因此你可以快速地掌握它的全部特性并投入开发。Vue 的整体思想是拥抱经典的 Web 技术，并在其上进行扩展。基于 HTML 的模板使得将已有的应用逐步迁移到 Vue 更为容易。\n\n声明式渲染&lt;div id&#x3D;&quot;app&quot;&gt;\n  &#123;&#123; message &#125;&#125;\n&lt;&#x2F;div&gt;\n\nvar app &#x3D; new Vue(&#123;\n  el: &#39;#app&#39;,\n  data: &#123;\n    message: &#39;Hello Vue!&#39;\n  &#125;\n&#125;)\n\n如上几行代码就是一个简单的vue程序，你会发现id为app的div里显示了message的值，看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是响应式的。我们要怎么确认呢？打开你的浏览器的 JavaScript 控制台 (就在这个页面打开)，并修改 app.message 的值，你将看到上例相应地更新。\n指令Vue有很多v-开头的指令，其本质是自定义属性。比如v-cloak, v-text, v-bind, v-model, v-on等等，下面将逐个介绍。\nv-cloak在上面的程序中，如果你的网速太慢，会发现最一开始网页会显示而非它的值，这涉及到Vue的生命周期，我们以后再聊。不过这样一个过程可能给用户带来不好的体验，因此你可以使用v-cloak指令防止页面加载时的闪烁。\n&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;\n  &#x2F;* \n    1、通过属性选择器 选择到 带有属性 v-cloak的标签  让他隐藏\n *&#x2F;\n  [v-cloak]&#123;\n    &#x2F;* 元素隐藏    *&#x2F;\n    display: none;\n  &#125;\n  &lt;&#x2F;style&gt;\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;!-- 2、 让带有插值 语法的   添加 v-cloak 属性 \n         在 数据渲染完场之后，v-cloak 属性会被自动去除，\n         v-cloak一旦移除也就是没有这个属性了  属性选择器就选择不到该标签\n\t\t 也就是对应的标签会变为可见\n    --&gt;\n    &lt;div  v-cloak  &gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n    var vm &#x3D; new Vue(&#123;\n      &#x2F;&#x2F;  el   指定元素 id 是 app 的元素  \n      el: &#39;#app&#39;,\n      &#x2F;&#x2F;  data  里面存储的是数据\n      data: &#123;\n        msg: &#39;Hello Vue&#39;\n      &#125;\n    &#125;);\n&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nv-text\nv-text指令用于将数据填充到标签中，作用于插值表达式类似，但是没有闪动问题\n如果数据中有HTML标签会将html标签一并输出\n注意：此处为单向绑定，数据对象上的值改变，插值会发生变化；但是当插值发生变化并不会影响数据对象的值\n\n&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;!--  \n\t\t注意:在指令中不要写插值语法  直接写对应的变量名称 \n        在 v-text 中 赋值的时候不要在写 插值语法\n\t\t一般属性中不加 &#123;&#123;&#125;&#125;  直接写 对应 的数据名 \n\t--&gt;\n    &lt;p v-text&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;p&gt;\n    &lt;p&gt;\n        &lt;!-- Vue  中只有在标签的 内容中 才用插值语法 --&gt;\n        &#123;&#123;msg&#125;&#125;\n    &lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n    new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n            msg: &#39;Hello Vue.js&#39;\n        &#125;\n    &#125;);\n\n&lt;&#x2F;script&gt;\n\n\n\nv-html\n用法和v-text 相似  但是他可以将HTML片段填充到标签中\n可能有安全问题, 一般只在可信任内容上使用 v-html，永不用在用户提交的内容上(因为谁也不知道某些傻叉用户会提交啥。。。)\n它与v-text区别在于v-text输出的是纯文本，浏览器不会对其再进行html解析，但v-html会将其当html标签解析后输出。\n\n&lt;div id&#x3D;&quot;app&quot;&gt;\n　　&lt;p v-html&#x3D;&quot;html&quot;&gt;&lt;&#x2F;p&gt; &lt;!-- 输出：html标签在渲染的时候被解析 --&gt;\n    \n    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;p&gt; &lt;!-- 输出：&lt;span&gt;通过双括号绑定&lt;&#x2F;span&gt; --&gt;\n    \n　　&lt;p v-text&#x3D;&quot;text&quot;&gt;&lt;&#x2F;p&gt; &lt;!-- 输出：&lt;span&gt;html标签在渲染的时候被源码输出&lt;&#x2F;span&gt; --&gt;\n&lt;&#x2F;div&gt;\n&lt;script&gt;\n　　let app &#x3D; new Vue(&#123;\n　　el: &quot;#app&quot;,\n　　data: &#123;\n　　　　message: &quot;&lt;span&gt;通过双括号绑定&lt;&#x2F;span&gt;&quot;,\n　　　　html: &quot;&lt;span&gt;html标签在渲染的时候被解析&lt;&#x2F;span&gt;&quot;,\n　　　　text: &quot;&lt;span&gt;html标签在渲染的时候被源码输出&lt;&#x2F;span&gt;&quot;,\n　　&#125;\n &#125;);\n&lt;&#x2F;script&gt;\n\nv-pre\n跳过编译过程显示原始信息\n\n&lt;span v-pre&gt;&#123;&#123; this will not be compiled &#125;&#125;&lt;&#x2F;span&gt;    \n&lt;!--  显示的是&#123;&#123; this will not be compiled &#125;&#125;  --&gt;\n&lt;span v-pre&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;span&gt;  \n&lt;!--   即使data里面定义了msg这里仍然是显示的&#123;&#123;msg&#125;&#125;  --&gt;\n&lt;script&gt;\n    new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n            msg: &#39;Hello Vue.js&#39;\n        &#125;\n    &#125;);\n\n&lt;&#x2F;script&gt;\n\nv-once\n只渲染一次，当数据改变时，插值的内容不会有响应式的改变\n\n  &lt;!-- 即使data里面定义了msg 后期我们修改了 仍然显示的是第一次data里面存储的数据即 Hello Vue.js  --&gt;\n     &lt;span v-once&gt;&#123;&#123; msg&#125;&#125;&lt;&#x2F;span&gt;    \n&lt;script&gt;\n    new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n            msg: &#39;Hello Vue.js&#39;\n        &#125;\n    &#125;);\n&lt;&#x2F;script&gt;\n\n\n\nv-on\nv-on是用来绑定事件的指令，如：v-on:click  \n该指令还有一个语法糖，上述指令可以缩写为：@click\n\n&lt;body&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n        &lt;div&gt;&#123;&#123;num&#125;&#125;&lt;&#x2F;div&gt;\n    &lt;div&gt;\n        &lt;button v-on:click&#x3D;&quot;num++&quot;&gt;点击1&lt;&#x2F;button&gt;\n        &lt;button @click&#x3D;&quot;num++&quot;&gt;点击2&lt;&#x2F;button&gt;\n        &lt;button @click&#x3D;&#39;handle&#39;&gt;点击3&lt;&#x2F;button&gt;\n        &lt;button @click&#x3D;&#39;handle()&#39;&gt;点击4&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;script&gt;\n        var vm &#x3D; new Vue(&#123;\n            el: &#39;#app&#39;,\n            data: &#123;\n                num: 0\n            &#125;,\n            methods: &#123;\n                handle: function()&#123;\n                    this.num ++;\n                &#125;\n            &#125;,\n        &#125;)\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n上面代码中四个按钮都可以实现对num加一 的操作，但是按钮3和4值得注意一下，按钮3在调用方法时没有加括号而按钮4加了括号，两种方式都是可以的。原因在于如果我们的方法不需要参数，在调用时就无须括号。\n\n\n\n\n\n\n\n\n\n实际上，如果方法内只需要一个event事件对象参数，我们在调用时也无须写括号，因为vue会帮助我们自动传入event对象，前提是方法的声明处只有一个参数。如果方法需要多个参数而我们没有传入，则默认传入event作为第一个参数，其他的会是undefined。\n事件修饰符\n在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。\nVue 不推荐我们操作DOM    为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符\n修饰符是由点开头的指令后缀来表示的\n\n&lt;!-- 阻止单击事件继续传播 --&gt;\n&lt;a v-on:click.stop&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;\n\n&lt;!-- 提交事件不再重载页面 --&gt;\n&lt;form v-on:submit.prevent&#x3D;&quot;onSubmit&quot;&gt;&lt;&#x2F;form&gt;\n\n&lt;!-- 修饰符可以串联   即阻止冒泡也阻止默认事件 --&gt;\n&lt;a v-on:click.stop.prevent&#x3D;&quot;doThat&quot;&gt;&lt;&#x2F;a&gt;\n\n&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;\n&lt;!-- 即事件不是从内部元素触发的 --&gt;\n&lt;div v-on:click.self&#x3D;&quot;doThat&quot;&gt;...&lt;&#x2F;div&gt;\n\n使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。\n\n按键修饰符\n在做项目中有时会用到键盘事件，在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符\n\n&lt;!-- 只有在 &#96;keyCode&#96; 是 13 时调用 &#96;vm.submit()&#96; --&gt;\n&lt;input v-on:keyup.13&#x3D;&quot;submit&quot;&gt;\n\n&lt;!-- -当点击enter 时调用 &#96;vm.submit()&#96; --&gt;\n&lt;input v-on:keyup.enter&#x3D;&quot;submit&quot;&gt;\n\n&lt;!--当点击enter或者space时  时调用 &#96;vm.alertMe()&#96;   --&gt;\n&lt;input type&#x3D;&quot;text&quot; v-on:keyup.enter.space&#x3D;&quot;alertMe&quot; &gt;\n\n常用的按键修饰符\n.enter &#x3D;&gt;    enter键\n.tab &#x3D;&gt; tab键\n.delete (捕获“删除”和“退格”按键) &#x3D;&gt;  删除键\n.esc &#x3D;&gt; 取消键\n.space &#x3D;&gt;  空格键\n.up &#x3D;&gt;  上\n.down &#x3D;&gt;  下\n.left &#x3D;&gt;  左\n.right &#x3D;&gt;  右\n\n&lt;script&gt;\n\tvar vm &#x3D; new Vue(&#123;\n        el:&quot;#app&quot;,\n        methods: &#123;\n              submit:function()&#123;&#125;,\n              alertMe:function()&#123;&#125;,\n        &#125;\n    &#125;)\n\n&lt;&#x2F;script&gt;\n\n自定义按键修饰符\n在Vue中可以通过config.keyCodes自定义按键修饰符别名\n\n&lt;div id&#x3D;&quot;app&quot;&gt;\n    预先定义了keycode 116（即F5）的别名为f5，因此在文字输入框中按下F5，会触发prompt方法\n    &lt;input type&#x3D;&quot;text&quot; v-on:keydown.f5&#x3D;&quot;prompt()&quot;&gt;\n&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n\t\n    Vue.config.keyCodes.f5 &#x3D; 116;\n\n    let app &#x3D; new Vue(&#123;\n        el: &#39;#app&#39;,\n        methods: &#123;\n            prompt: function() &#123;\n                alert(&#39;我是 F5！&#39;);\n            &#125;\n        &#125;\n    &#125;);\n&lt;&#x2F;script&gt;\n\nv-bind\nv-bind 指令被用来响应地更新 HTML 属性\nv-bind:href    可以缩写为    :href;\n\n&lt;!-- 绑定一个属性 --&gt;\n&lt;img v-bind:src&#x3D;&quot;imageSrc&quot;&gt;\n\n&lt;!-- 缩写 --&gt;\n&lt;img :src&#x3D;&quot;imageSrc&quot;&gt;\n\n绑定对象\n我们可以给v-bind:class 一个对象，以动态地切换class。\n注意：v-bind:class指令可以与普通的class特性共存\n\n1、 v-bind 中支持绑定一个对象 \n\t如果绑定的是一个对象 则 键为 对应的类名  值 为对应data中的数据 \n&lt;!-- \n\tHTML最终渲染为 &lt;ul class&#x3D;&quot;box textColor textSize&quot;&gt;&lt;&#x2F;ul&gt;\n\t注意：\n\t\ttextColor，textSize  对应的渲染到页面上的CSS类名\t\n\t\tisColor，isSize  对应vue data中的数据  如果为true 则对应的类名 渲染到页面上 \n\n\n\t\t当 isColor 和 isSize 变化时，class列表将相应的更新，\n\t\t例如，将isSize改成false，\n\t\tclass列表将变为 &lt;ul class&#x3D;&quot;box textColor&quot;&gt;&lt;&#x2F;ul&gt;\n--&gt;\n\n&lt;ul class&#x3D;&quot;box&quot; v-bind:class&#x3D;&quot;&#123;textColor:isColor, textSize:isSize&#125;&quot;&gt;\n    &lt;li&gt;学习Vue&lt;&#x2F;li&gt;\n    &lt;li&gt;学习Node&lt;&#x2F;li&gt;\n    &lt;li&gt;学习React&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n  &lt;div v-bind:style&#x3D;&quot;&#123;color:activeColor,fontSize:activeSize&#125;&quot;&gt;对象语法&lt;&#x2F;div&gt;\n\n&lt;sript&gt;\nvar vm&#x3D; new Vue(&#123;\n    el:&#39;.box&#39;,\n    data:&#123;\n        isColor:true,\n        isSize:true，\n    \tactiveColor:&quot;red&quot;,\n        activeSize:&quot;25px&quot;,\n    &#125;\n&#125;)\n&lt;&#x2F;sript&gt;\n&lt;style&gt;\n\n    .box&#123;\n        border:1px dashed #f0f;\n    &#125;\n    .textColor&#123;\n        color:#f00;\n        background-color:#eef;\n    &#125;\n    .textSize&#123;\n        font-size:30px;\n        font-weight:bold;\n    &#125;\n&lt;&#x2F;style&gt;\n\n绑定class2、  v-bind 中支持绑定一个数组    数组中classA和 classB 对应为data中的数据\n\n这里的classA  对用data 中的  classA\n这里的classB  对用data 中的  classB\n&lt;ul class&#x3D;&quot;box&quot; :class&#x3D;&quot;[classA, classB]&quot;&gt;\n    &lt;li&gt;学习Vue&lt;&#x2F;li&gt;\n    &lt;li&gt;学习Node&lt;&#x2F;li&gt;\n    &lt;li&gt;学习React&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n&lt;script&gt;\nvar vm&#x3D; new Vue(&#123;\n    el:&#39;.box&#39;,\n    data:&#123;\n        classA:‘textColor‘,\n        classB:‘textSize‘\n    &#125;\n&#125;)\n&lt;&#x2F;script&gt;\n&lt;style&gt;\n    .box&#123;\n        border:1px dashed #f0f;\n    &#125;\n    .textColor&#123;\n        color:#f00;\n        background-color:#eef;\n    &#125;\n    .textSize&#123;\n        font-size:30px;\n        font-weight:bold;\n    &#125;\n&lt;&#x2F;style&gt;\n\n绑定对象和数组的区别\n绑定对象的时候 对象的属性 即要渲染的类名 对象的属性值对应的是 data 中的数据 \n绑定数组的时候数组里面存的是data 中的数据 \n\n绑定style&lt;div v-bind:style&#x3D;&quot;styleObject&quot;&gt;绑定样式对象&lt;&#x2F;div&gt;&#39;\n \n&lt;!-- CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来)    --&gt;\n &lt;div v-bind:style&#x3D;&quot;&#123; color: activeColor, fontSize: fontSize,background:&#39;red&#39; &#125;&quot;&gt;内联样式&lt;&#x2F;div&gt;\n\n&lt;!--组语法可以将多个样式对象应用到同一个元素 --&gt;\n&lt;div v-bind:style&#x3D;&quot;[styleObj1, styleObj2]&quot;&gt;&lt;&#x2F;div&gt;\n\n\n&lt;script&gt;\n\tnew Vue(&#123;\n      el: &#39;#app&#39;,\n      data: &#123;\n        styleObject: &#123;\n          color: &#39;green&#39;,\n          fontSize: &#39;30px&#39;,\n          background:&#39;red&#39;\n        &#125;，\n        activeColor: &#39;green&#39;,\n   \t\tfontSize: &quot;30px&quot;\n      &#125;,\n      styleObj1: &#123;\n             color: &#39;red&#39;\n       &#125;,\n       styleObj2: &#123;\n            fontSize: &#39;30px&#39;\n       &#125;\n\n&lt;&#x2F;script&gt;\n\n分支结构v-if 使用场景\n多个元素 通过条件判断展示或者隐藏某个元素。或者多个元素\n进行两个视图之间的切换\n\n&lt;div id&#x3D;&quot;app&quot;&gt;\n        &lt;!--  判断是否加载，如果为真，就加载，否则不加载--&gt;\n        &lt;span v-if&#x3D;&quot;flag&quot;&gt;\n           如果flag为true则显示,false不显示!\n        &lt;&#x2F;span&gt;\n&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n    var vm &#x3D; new Vue(&#123;\n        el:&quot;#app&quot;,\n        data:&#123;\n            flag:true\n        &#125;\n    &#125;)\n&lt;&#x2F;script&gt;\n\n----------------------------------------------------------\n\n    &lt;div v-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;A&#39;&quot;&gt;\n       A\n    &lt;&#x2F;div&gt;\n  &lt;!-- v-else-if紧跟在v-if或v-else-if之后   表示v-if条件不成立时执行--&gt;\n    &lt;div v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;B&#39;&quot;&gt;\n       B\n    &lt;&#x2F;div&gt;\n    &lt;div v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;C&#39;&quot;&gt;\n       C\n    &lt;&#x2F;div&gt;\n  &lt;!-- v-else紧跟在v-if或v-else-if之后--&gt;\n    &lt;div v-else&gt;\n       Not A&#x2F;B&#x2F;C\n    &lt;&#x2F;div&gt;\n\n&lt;script&gt;\n    new Vue(&#123;\n      el: &#39;#app&#39;,\n      data: &#123;\n        type: &#39;C&#39;\n      &#125;\n    &#125;)\n&lt;&#x2F;script&gt;\n\nv-show 和 v-if的区别\nv-show本质就是标签display设置为none，控制隐藏\nv-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，故v-show性能更好一点。\n\n\nv-if是动态的向DOM树内添加或者删除DOM元素\nv-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件\n\n\n\n循环结构v-for\n用于循环的数组里面的值可以是对象，也可以是普通元素\n\n&lt;ul id&#x3D;&quot;example-1&quot;&gt;\n   &lt;!-- 循环结构-遍历数组  \n\titem 是我们自己定义的一个名字  代表数组里面的每一项  \n\titems对应的是 data中的数组--&gt;\n  &lt;li v-for&#x3D;&quot;item in items&quot;&gt;\n    &#123;&#123; item.message &#125;&#125;\n  &lt;&#x2F;li&gt; \n\n&lt;&#x2F;ul&gt;\n&lt;script&gt;\n new Vue(&#123;\n  el: &#39;#example-1&#39;,\n  data: &#123;\n    items: [\n      &#123; message: &#39;Foo&#39; &#125;,\n      &#123; message: &#39;Bar&#39; &#125;\n    ]，\n   \n  &#125;\n&#125;)\n&lt;&#x2F;script&gt;\n\n\n不推荐同时使用 v-if 和 v-for\n当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。\n\n   &lt;!--  循环结构-遍历对象\n\t\tv 代表   对象的value\n\t\tk  代表对象的 键 \n\t\ti  代表索引\t\n\t---&gt; \n     &lt;div v-if&#x3D;&#39;v&#x3D;&#x3D;13&#39; v-for&#x3D;&#39;(v,k,i) in obj&#39;&gt;&#123;&#123;v + &#39;---&#39; + k + &#39;---&#39; + i&#125;&#125;&lt;&#x2F;div&gt;\n\n&lt;script&gt;\n new Vue(&#123;\n  el: &#39;#example-1&#39;,\n  data: &#123;\n    items: [\n      &#123; message: &#39;Foo&#39; &#125;,\n      &#123; message: &#39;Bar&#39; &#125;\n    ]，\n    obj: &#123;\n        uname: &#39;zhangsan&#39;,\n        age: 13,\n        gender: &#39;female&#39;\n    &#125;\n  &#125;\n&#125;)\n&lt;&#x2F;script&gt;\n\nkey 的作用\n\nkey来给每个节点做一个唯一标识\nkey的作用主要是为了高效的更新虚拟DOM\n\n&lt;ul&gt;\n  &lt;li v-for&#x3D;&quot;item in items&quot; :key&#x3D;&quot;item.id&quot;&gt;...&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n购物车案例需求说明：\n\n表格显示购物车的商品内容\n可以增加或者减少物品的数量，并且可以删除\n显示购物车商品的总价\n\n实现图：\n\n代码:\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Title&lt;&#x2F;title&gt;\n  &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;stackpath.bootstrapcdn.com&#x2F;bootstrap&#x2F;4.3.1&#x2F;css&#x2F;bootstrap.min.css&quot; integrity&#x3D;&quot;sha384-ggOyR0iXCbMQv3Xipma34MD+dH&#x2F;1fQ784&#x2F;j6cY&#x2F;iJTQUOhcWr7x9JvoRxT2MZw1T&quot; crossorigin&#x3D;&quot;anonymous&quot;&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;div id&#x3D;&quot;app&quot; class&#x3D;&quot;container&quot;&gt;\n  &lt;table class&#x3D;&quot;table table-hover table-bordered&quot;&gt;\n    &lt;thead&gt;\n    &lt;tr&gt;\n      &lt;th scope&#x3D;&quot;col&quot;&gt;ID&lt;&#x2F;th&gt;\n      &lt;th scope&#x3D;&quot;col&quot;&gt;书籍名称&lt;&#x2F;th&gt;\n      &lt;th scope&#x3D;&quot;col&quot;&gt;出版日期&lt;&#x2F;th&gt;\n      &lt;th scope&#x3D;&quot;col&quot;&gt;价格&lt;&#x2F;th&gt;\n      &lt;th scope&#x3D;&quot;col&quot;&gt;购买数量&lt;&#x2F;th&gt;\n      &lt;th scope&#x3D;&quot;col&quot;&gt;操作&lt;&#x2F;th&gt;\n    &lt;&#x2F;tr&gt;\n    &lt;&#x2F;thead&gt;\n    &lt;tbody&gt;\n    &lt;tr v-for&#x3D;&quot;(book,index) in books&quot;&gt;\n      &lt;td&gt;&#123;&#123;index+1&#125;&#125;&lt;&#x2F;td&gt;\n      &lt;td&gt;&#123;&#123;book.name&#125;&#125;&lt;&#x2F;td&gt;\n      &lt;td&gt;&#123;&#123;book.date&#125;&#125;&lt;&#x2F;td&gt;\n      &lt;td&gt;&#123;&#123;book.price | showPrice&#125;&#125;&lt;&#x2F;td&gt;\n      &lt;td&gt;\n        &lt;button class&#x3D;&quot;btn btn-sm btn-secondary&quot; @click&#x3D;&quot;decrement(index)&quot;&gt;-&lt;&#x2F;button&gt;\n        &#123;&#123;book.count&#125;&#125;\n        &lt;button class&#x3D;&quot;btn btn-sm btn-secondary&quot; @click&#x3D;&quot;increment(index)&quot;&gt;+&lt;&#x2F;button&gt;\n      &lt;&#x2F;td&gt;\n      &lt;td&gt;\n        &lt;button class&#x3D;&quot;btn btn-sm btn-danger&quot; @click&#x3D;&quot;removeItem(index)&quot;&gt;删除&lt;&#x2F;button&gt;\n      &lt;&#x2F;td&gt;\n    &lt;&#x2F;tr&gt;\n    &lt;&#x2F;tbody&gt;\n  &lt;&#x2F;table&gt;\n  &lt;span&gt;总价格:&#123;&#123;totalPrice | showPrice&#125;&#125;&lt;&#x2F;span&gt;\n&lt;&#x2F;div&gt;\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.3.1.slim.min.js&quot; integrity&#x3D;&quot;sha384-q8i&#x2F;X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo&quot; crossorigin&#x3D;&quot;anonymous&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;popper.js&#x2F;1.14.7&#x2F;umd&#x2F;popper.min.js&quot; integrity&#x3D;&quot;sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1&quot; crossorigin&#x3D;&quot;anonymous&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;stackpath.bootstrapcdn.com&#x2F;bootstrap&#x2F;4.3.1&#x2F;js&#x2F;bootstrap.min.js&quot; integrity&#x3D;&quot;sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf&#x2F;nJGzIxFDsf4x0xIM+B07jRM&quot; crossorigin&#x3D;&quot;anonymous&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script&gt;\n  const app &#x3D; new Vue(&#123;\n    el: &quot;#app&quot;,\n    data: &#123;\n      books: [\n        &#123;\n          name: &#39;《算法导论》&#39;,\n          date: &#39;2016-9&#39;,\n          price: 85,\n          count: &#39;1&#39;\n        &#125;,\n        &#123;\n          name: &#39;《UNIX编程艺术》&#39;,\n          date: &#39;2016-2&#39;,\n          price: 99,\n          count: &#39;1&#39;\n        &#125;,\n        &#123;\n          name: &#39;《编程珠玑》&#39;,\n          date: &#39;2008-10&#39;,\n          price: 108,\n          count: &#39;1&#39;\n        &#125;,\n        &#123;\n          name: &#39;《代码大全》&#39;,\n          date: &#39;2006-3&#39;,\n          price: 79,\n          count: &#39;1&#39;\n        &#125;\n      ],\n    &#125;,\n    filters: &#123;\n      showPrice(value)&#123;\n        return &#39;￥&#39; + value.toFixed(2);\n      &#125;\n    &#125;,\n    computed: &#123;\n      totalPrice()&#123;\n        let total &#x3D; 0;\n        for (let item of this.books)&#123;\n          total +&#x3D; item.price * item.count;\n        &#125;\n        return total;\n      &#125;\n    &#125;,\n    methods: &#123;\n      increment(index)&#123;\n        this.books[index].count++;\n      &#125;,\n      decrement(index)&#123;\n        if (this.books[index].count &gt; 0)&#123;\n          this.books[index].count--;\n        &#125;\n      &#125;,\n      removeItem(index)&#123;\n        this.books.splice(index,1);\n      &#125;\n    &#125;\n  &#125;);\n&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n","slug":"Vue基础语法","date":"2020-03-04T08:34:00.000Z","categories_index":"Vue","tags_index":"笔记,Vue","author_index":"Cao Wei"},{"id":"01d9c49bbeb2b94841aa8e6f58e445bb","title":"SpringBoot 日志全解","content":"日志1、日志框架介绍主流的日志框架：\nJUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j….\n\n\n\n日志门面  （日志的抽象层）\n日志实现\n\n\n\nJCL（Jakarta  Commons Logging）    SLF4j（Simple  Logging Facade for Java）    jboss-logging\nLog4j  JUL（java.util.logging）  Log4j2  Logback\n\n\n一般来说在开发中在左边选择一个抽象层，右边选择一个实现。\nSpringBoot默认选用 SLF4j和logback，SpringBoot的底层是Spring，而Spring默认是JCL。\n2、SLF4J的使用如何在系统中使用SLF4J？可以参考：https://www.slf4j.org\n开发时候日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法。\n给系统里导入slf4j的jar和  logback的实现jar，就可以进行如下示例：\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class HelloWorld &#123;\n  public static void main(String[] args) &#123;\n    Logger logger &#x3D; LoggerFactory.getLogger(HelloWorld.class);\n    logger.info(&quot;Hello World&quot;);\n  &#125;\n&#125;\n\n\n每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件；\n遗留问题下面是几种框架的日志选择：\nSpringBoot（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx\n统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？\n\n如何让系统中所有的日志都统一到slf4j；\n1、将系统中其他日志框架先排除出去；\n2、用中间包来替换原有的日志框架；\n3、我们导入slf4j其他的实现\n3、SpringBoot的日志关系SpringBoot的日志starter是：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-logging&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n底层的依赖关系：\n\n总结：\n​    1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录\n​    2）、SpringBoot也把其他的日志都替换成了slf4j；\n​    3）、中间替换包？\n@SuppressWarnings(&quot;rawtypes&quot;)\npublic abstract class LogFactory &#123;\n\n    static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J &#x3D; &quot;http:&#x2F;&#x2F;www.slf4j.org&#x2F;codes.html#unsupported_operation_in_jcl_over_slf4j&quot;;\n\n    static LogFactory logFactory &#x3D; new SLF4JLogFactory();\n\n\n4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？\nSpring框架用的是commons-logging；\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;commons-logging&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;commons-logging&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;exclusion&gt;\n    &lt;&#x2F;exclusions&gt;\n&lt;&#x2F;dependency&gt;\nSpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；\n4、日志使用默认配置SpringBoot默认帮我们配置好了日志；\n&#x2F;&#x2F;记录器\nLogger logger &#x3D; LoggerFactory.getLogger(getClass());\n@Test\npublic void contextLoads() &#123;\n    &#x2F;&#x2F;System.out.println();\n\n    &#x2F;&#x2F;日志的级别；\n    &#x2F;&#x2F;由低到高   trace&lt;debug&lt;info&lt;warn&lt;error\n    &#x2F;&#x2F;可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效\n    logger.trace(&quot;这是trace日志...&quot;);\n    logger.debug(&quot;这是debug日志...&quot;);\n    &#x2F;&#x2F;SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别\n    logger.info(&quot;这是info日志...&quot;);\n    logger.warn(&quot;这是warn日志...&quot;);\n    logger.error(&quot;这是error日志...&quot;);\n\n\n&#125;\n\n日志输出格式：\n\n\n\n\n\n\n\n\n\n    %d表示日期时间，\n    %thread表示线程名，\n    %-5level：级别从左显示5个字符宽度\n    %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 \n    %msg：日志消息，\n    %n是换行符\n--&gt;\n%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n\n\nSpringBoot修改日志的默认配置\nlogging.level.com.atguigu&#x3D;trace\n\n\n#logging.path&#x3D;\n# 不指定路径在当前项目下生成springboot.log日志\n# 可以指定完整的路径；\n#logging.file&#x3D;G:&#x2F;springboot.log\n\n# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件\nlogging.path&#x3D;&#x2F;spring&#x2F;log\n\n#  在控制台输出的日志的格式\nlogging.pattern.console&#x3D;%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n\n# 指定文件中日志输出的格式\nlogging.pattern.file&#x3D;%d&#123;yyyy-MM-dd&#125; &#x3D;&#x3D;&#x3D; [%thread] &#x3D;&#x3D;&#x3D; %-5level &#x3D;&#x3D;&#x3D; %logger&#123;50&#125; &#x3D;&#x3D;&#x3D;&#x3D; %msg%n\n\n\n\n\nlogging.file\nlogging.path\nExample\nDescription\n\n\n\n(none)\n(none)\n\n只在控制台输出\n\n\n指定文件名\n(none)\nmy.log\n输出日志到my.log文件\n\n\n(none)\n指定目录\n/var/log\n输出到指定目录的 spring.log 文件中\n\n\n指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了\n\n\n\nLogging System\nCustomization\n\n\n\nLogback\nlogback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy\n\n\nLog4j2\nlog4j2-spring.xml or log4j2.xml\n\n\nJDK (Java Util Logging)\nlogging.properties\n\n\nlogback.xml：直接就被日志框架识别了；\nlogback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能\n&lt;springProfile name&#x3D;&quot;staging&quot;&gt;\n    &lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt;\n  \t可以指定某段配置只在某个环境下生效\n&lt;&#x2F;springProfile&gt;\n\n\n如：\n&lt;appender name&#x3D;&quot;stdout&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;\n    &lt;!--\n        日志输出格式：\n   %d表示日期时间，\n   %thread表示线程名，\n   %-5level：级别从左显示5个字符宽度\n   %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 \n   %msg：日志消息，\n   %n是换行符\n        --&gt;\n    &lt;layout class&#x3D;&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;\n        &lt;springProfile name&#x3D;&quot;dev&quot;&gt;\n            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;&#x2F;pattern&gt;\n        &lt;&#x2F;springProfile&gt;\n        &lt;springProfile name&#x3D;&quot;!dev&quot;&gt;\n            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; &#x3D;&#x3D;&#x3D;&#x3D; [%thread] &#x3D;&#x3D;&#x3D;&#x3D; %-5level %logger&#123;50&#125; - %msg%n&lt;&#x2F;pattern&gt;\n        &lt;&#x2F;springProfile&gt;\n    &lt;&#x2F;layout&gt;\n&lt;&#x2F;appender&gt;\n\n\n\n如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误\n no applicable action for [springProfile]\n5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换；\nslf4j+log4j的方式：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;artifactId&gt;logback-classic&lt;&#x2F;artifactId&gt;\n            &lt;groupId&gt;ch.qos.logback&lt;&#x2F;groupId&gt;\n        &lt;&#x2F;exclusion&gt;\n        &lt;exclusion&gt;\n            &lt;artifactId&gt;log4j-over-slf4j&lt;&#x2F;artifactId&gt;\n            &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;\n        &lt;&#x2F;exclusion&gt;\n    &lt;&#x2F;exclusions&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n\n切换为log4j2：\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;artifactId&gt;spring-boot-starter-logging&lt;&#x2F;artifactId&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;&#x2F;exclusion&gt;\n    &lt;&#x2F;exclusions&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n","slug":"SpringBoot日志全解","date":"2020-02-27T09:44:00.000Z","categories_index":"SpringBoot","tags_index":"笔记,SpringBoot","author_index":"Cao Wei"},{"id":"4c42910cd96b92369d87ca796bbcead8","title":"SpringBoot 配置文件详解（告别XML）","content":"前言上篇笔记中提到SpringBoot简化Spring的开发是通过大量的默认配置，然而在开发中我们有时需要改变这些默认约定，所以要使用配置文件。\n配置文件SpringBoot中的配置文件明必须是application，如：application.yml，application.properties，application.yaml\n配置文件的作用: 帮我们修改自动配置的默认值;\nYAMLYAML 语言（发音 /ˈjæməl/ ）的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。\n它的基本语法如下:\n\n\n\n\n\n\n\n\n\n\n大小写敏感\n使用缩进表示层级关系\n缩进时不允许使用Tab键，只允许使用空格。\n缩进的空格数目不重要，只要相同层级的元素左侧对齐即可\n# 表示注释, 作用一直到行尾\n\nYAML支持的数据结构:\n\n\n\n\n\n\n\n\n\n\n对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）\n数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）\n纯量（scalars）：单个的、不可再分的值\n\n数据结构纯量(字面量)所谓的字面量就是指字符串，数字，布尔值等基本数据；\n字符串默认不需要单引号和双引号，如果你非要用的话，请看下面的规则：\n“”：双引号，不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思\n\n\n\n\n\n\n\n\n\n举个栗子：name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi\n‘’：单引号，会转义特殊字符，特殊字符最终只是一个普通的字符串数据\n\n\n\n\n\n\n\n\n\n举个栗子：name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi\n对象（键值对的集合）k: v：对象的一组键值对，使用冒号结构表示，冒号后必须有空格\npet:\n    name:  cat\n    age:  2\n    sex:  公的\n\n如果你愿意的话，也可以把它写成一行：\npet:  &#123;name: cat,gender: 公的,age: 22&#125;\n\n数组，List集合基本写法\nlist:\n    - item1\n    - item2\n    - item3\n\n写成一行的话就是：\nlist: [item1,item2,item3]\n\n开发实例导入坐标在pom.xml中加入如下坐标：\n&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n\n编写实体类：@Component\n@ConfigurationProperties(prefix &#x3D; &quot;person&quot;)\npublic class Person &#123;\n\n    private String userName;\n    private Integer age;\n    private Date birthday;\n    private Boolean sex;\n    private Map&lt;String,Object&gt; map;\n    private List&lt;Object&gt; list;\n    private Cat cat;\n    \n    getter，setter，toString方法此处省略......\n        \n&#125;\n\n@Component\npublic class Cat &#123;\n\n    private String name;\n    private Integer age;\n\n    getter，setter，toString方法此处省略......\n    \n&#125;\n\n配置文件person:\n  username: 张三\n  age: 18\n  birthday: 2020&#x2F;02&#x2F;26\n  sex: false\n  map: &#123;k1: v1,k2: 22&#125;\n  list:\n    - item1\n    - item2\n    - item3\n  cat:\n    name: 猫咪\n    age: 2\n\n测试@SpringBootTest\nclass Day02SettingsApplicationTests &#123;\n\n    @Autowired\n    Person person;\n\n    @Test\n    void contextLoads() &#123;\n        System.out.println(person);\n    &#125;\n\n&#125;\n\nproperties上述yaml配置等效：\nperson.user-name&#x3D;张三\nperson.age&#x3D;18\nperson.birthday&#x3D;2020&#x2F;02&#x2F;26\nperson.sex&#x3D;true\nperson.map.k1&#x3D;v1\nperson.map.k2&#x3D;v2\nperson.list&#x3D;item1,item2,item3\nperson.cat.name&#x3D;猫咪\nperson.cat.age&#x3D;2\n\n\n\n\n\n\n\n\n\n\n当工程中同时有两种配置文件时，将以properties优先\n中文乱码问题如果使用properties配置时中文数据出现乱码，在设置中找到File Encoding，将配置文件字符设置为UTF-8，并且勾选 Transparent native-to-ascii conversion\n\n配置文件两种注入方式的对比配置文件值注入有两种方式，一个是Spring Boot的@ConfigurationProperties注解，另一个是spring原先的@value注解\n\n\n\n\n@Value\n@ConfigurationProperties\n\n\n\n功能\n一个个指定注入\n批量注入配置文件中的属性\n\n\n松散绑定\n不支持\n支持\n\n\nSpEL\n支持\n不支持\n\n\nJSR303数据校验\n不支持\n支持\n\n\n复杂类型封装\n不支持\n支持\n\n\n松散绑定\n\n\n\n\n\n\n\n\n例如Person中有lastName属性，在配置文件中可以写成lastName或lastname或last-name或last_name等等\nSpEL\n\n\n\n\n\n\n\n\n举个栗子：\n配置文件\nperson.name&#x3D;#&#123;2019-1998+1&#125;\n\nPerson类\n&#x2F;**\n*\t使用@ConfigurationProperties注解，会抛出异常\n*&#x2F;\n@Component\n@ConfigurationProperties(prefix &#x3D; &quot;person&quot;)\npublic class Person &#123;\n    private Integer age;\n    \n----------------------------------------------------------------------------\n&#x2F;**\n*\t使用@Value注解，正常注入\n*&#x2F;\n    @Component\npublic class Person &#123;\n    @Value(&quot;$&#123;person.age&#125;&quot;)\n    private Integer age;\n\n\nJSR303数据校验@ConfigurationProperties注解可以使用JSR303数据校验\n\n@Value注解不支持数据校验\n\n配置的其他知识@PropertySource@PropertySource注解的作用是加载指定位置的配置文件，其指可以是数组，即可以加载多个配置文件\nSpringBoot默认加载的配置文件名称是application，如果配置文件名不是这个是不会被容器加载的。\n\n\n\n\n\n\n\n\n\n\n使用这个注解加载配置文件就需要配置类使用@component等注解而不是等待@EnableConfigurationProperties激活，而且不支持yaml，只能是properties\n@ImportResource@ImportResource注解用于导入Spring的配置文件，让配置文件里面的内容生效；(就是以前写的springmvc.xml、applicationContext.xml)\nSpring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；\n\n想让Spring的配置文件生效，加载进来；必须把@ImportResource标注在一个配置类上\n\n\n\n\n\n\n\n\n\n注意：此处应该把该注解加在入口类上而不是测试类\n\n@Configuration这是SpringBoot推荐的添加注解的方式，并且推荐使用全注解的方式。\n配置类加上**@Configuration**相当于 Spring配置文件。\n@Bean使用@Bean给容器中添加组件，其中组件名就是方法名。\n\n配置文件占位符随机值$&#123;random.value&#125;\n$&#123;random.int&#125;\n$&#123;random.long&#125;\n$&#123;random.int(10)&#125;\n$&#123;random.int[1024,65536]&#125;\n\n引用配置好的其他属性\n如果引用的属性没有值，可以使用:指定他的默认值\nProfileProfile是Spring对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境\n多profile文件形式\n此时运行程序，启动的是8080端口，但是我们可以自定义激活配置文件：\n\n\n\n\n\n\n\n\n\n举个栗子：如果在主配置文件中加入以下代码\nspring.profiles.active&#x3D;dev\n\n再次运行程序，启动的则是我们配置的8081端口\nyml支持多文档块我们可以不用那么多的配置文件，只需要将主配置文件分块即可：\nserver:\n  port: 8080\nspring:\n  profiles:\n    active: prod\n---\nserver:\n  port: 8081\nspring:\n  profiles: dev\n---\nserver:\n  port: 8082\nspring:\n  profiles: prod\n\n激活指定profile总结\n在配置文件中指定 spring.profiles.active=dev（如上）\n\n项目打包后在命令行启动\njava -jar xxx.jar --spring.profiles.active&#x3D;dev;\n虚拟机参数\n\n\n\n配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件\n\n\n\n\n\n\n\n\n\nfile: .&#x2F;config&#x2F;\n\nfile: .&#x2F;\n\nclasspath: &#x2F;config&#x2F;\n\nclasspath: &#x2F;\n优先级由高到底，高优先级的配置会覆盖低优先级的配置（优先级低的先加载）；\nSpringBoot会从这四个位置全部加载主配置文件；互补配置；\n\n\n\n\n\n\n\n\n\n\n项目根目录下的配置文件maven在打包时不会编译进去，需要更改一下配置\n&lt;resources&gt;\n\t&lt;resource&gt;\n\t\t&lt;directory&gt;.&lt;&#x2F;directory&gt;\n\t\t&lt;filtering&gt;true&lt;&#x2F;filtering&gt;\n\t\t&lt;includes&gt;\n\t\t\t&lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;\n\t\t\t&lt;include&gt;**&#x2F;*.yaml&lt;&#x2F;include&gt;\n\t\t&lt;&#x2F;includes&gt;\n\t&lt;&#x2F;resource&gt;\n&lt;&#x2F;resources&gt;\n\n\n\n\n\n\n\n\n\n\n还可以使用spring.config.location参数指定默认配置文件的位置\n项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；\njava -jar xxx.jar --spring.config.location&#x3D;&#x2F;home&#x2F;cheerway&#x2F;application.yaml\n\n\n外部配置加载顺序SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置\n\n命令行参数 \n所有的配置都可以在命令行上进行指定\njava -jar xxx.jar --server.port&#x3D;8087  --server.context-path&#x3D;&#x2F;abcCopy to clipboardErrorCopied\n\n多个配置用空格分开； –配置项=值\n\n来自java:comp/env的JNDI属性 ⤴️\n\nJava系统属性（System.getProperties()） ⤴️\n\n操作系统环境变量 ⤴️\n\nRandomValuePropertySource配置的random.*属性值 ⤴️\n\n\n由jar包外向jar包内进行寻找；\n再来加载不带profile\n\njar包外部的application.properties或application.yml(不带spring.profile)配置文件 ⤴️\n**jar包内部的application.properties或application.yml(不带spring.profile)配置文件 **⤴️\n\n优先加载带profile\n\njar包外部的application-&#123;profile&#125;.properties或application.yml(带spring.profile)配置文件 ⤴️\n\n**jar包内部的application-&#123;profile&#125;.properties或application.yml(带spring.profile)配置文件 **⤴️\n\n@Configuration注解类上的@PropertySource ⤴️\n\n通过SpringApplication.setDefaultProperties指定的默认属性 ⤴️\n\n\n所有支持的配置加载来源，请参考官方文档。\n","slug":"SpringBoot 配置文件详解（告别XML）","date":"2020-02-26T09:57:00.000Z","categories_index":"SpringBoot","tags_index":"笔记,SpringBoot","author_index":"Cao Wei"},{"id":"7039c293fbb0465a1b618eb4fc99fd7e","title":"SpringBoot-HelloWorld","content":"SpringBoot-HelloWorld1. 为什么要用SpringBoot相信用过SSM框架的小伙伴都知道，在使用过程中我们必须配置大量的.xml文件来整合各个框架并对其参数进行配置，这项工作对于大型项目来说苦不堪言。\n于是Pivotal 团队提供了全新的框架Spring Boot，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架采用“习惯优于配置”的方式开发，可以快速构建Spring应用。\nSpringBoot 主要有以下优点：\n\n\n\n\n\n\n\n\n\n\n快速创建独立运行的Spring项目以及与主流框架集成\n使用嵌入式的Servlet容器，应用无需打成WAR包\nstarters自动依赖与版本控制\n大量的自动配置，简化开发，也可修改默认值\n无需配置XML，无代码生成，开箱即用\n准生产环境的运行时应用监控\n与云计算的天然集成\n\n虽然Spring Boot采用“约定大于配置”的方式来简化开发，但是对于不了解默认约定的小白来说可能并不友好\n2. 创建SpringBoot应用的方式1. 使用官网的初始化入口在如下界面中填写相关信息\n\n然后点击Generate即可生成一个SpringBoot项目，之后用IDEA打开即可。\n２. 使用IDEA提供的Spring Initialize创建项目\n\n\n\n\n\n\n\n\n以下步骤需要联网\n本项目使用的环境: \n\n\n\n工具\n版本\n\n\n\nMaven\n3.3+\n\n\nJDK\n1.8\n\n\n\n创建项目时选择Spring Initializr\n\n\n完善项目的相关信息\n\n\n选择需要加入的依赖，本项目中我们只需要添加web\n\n\n创建完成以后IDEA会联网帮我们创建Spring Boot项目，如下图\n\n\n\n默认生成的Spring Boot项目\n\n主程序已经生成好了，我们只需要完成我们自己的逻辑\n\nresources文件夹中目录结构\n\nstatic：保存所有的静态资源； js、css、images；\ntemplates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；\napplication.properties：Spring Boot应用的配置文件；可以修改一些默认设置；\n\n\n\n3. 完善HelloWorld项目1. 编写Controller在主包下新建controller包并且在该包中新建一个class文件, 文件名为: HelloController\npackage com.cheerway.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@Controller\npublic class HelloController &#123;\n\n    @ResponseBody\n    @RequestMapping(&quot;&#x2F;hello&quot;)\n    public String hello()&#123;\n        return &quot;Hello&quot;;\n    &#125;\n&#125;\n\n2. 运行项目然后我们可以打开自动生成的启动类, 运行该类可以看到控制台输出的Log\n\n最后用浏览器访问localhost:8080/hello, 就可以看到项目运行的结果\n\n3. 简化部署\nMaven插件\n该插件可以帮我们把springboot项目打成jar包, 达到快速部署的目的\n&lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n            &lt;&#x2F;plugin&gt;\n        &lt;&#x2F;plugins&gt;\n    &lt;&#x2F;build&gt;\n使用mvn pakage命令进行打包\n\n使用java -jar命令运行该jar包\n\n\n4. HelloWorld入门程序探究依赖\n&lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.2.4.RELEASE&lt;&#x2F;version&gt;\n        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;\n&lt;&#x2F;parent&gt;\n这是我们项目依赖的父项目,他的父项目是\n&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.2.4.RELEASE&lt;&#x2F;version&gt;\n    &lt;relativePath&gt;..&#x2F;..&#x2F;spring-boot-dependencies&lt;&#x2F;relativePath&gt;\n  &lt;&#x2F;parent&gt;\n这个才是管理SpringBoot全部版本的项目\n\n启动器\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\nspring-boot-starter: spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；\nSpring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器\n主程序\npackage com.cheerway;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n&#x2F;**\n * @SpringBootApplication 说明这是一个SpringBoot应用的入口\n *&#x2F;\n@SpringBootApplication\npublic class HelloWorldApplication &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(HelloWorldApplication.class, args);\n    &#125;\n\n&#125;\n\n\n@SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；\n该注解其实是一个组合注解, 查看源码: \n@Target(&#123;ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(\n    excludeFilters &#x3D; &#123;@Filter(\n    type &#x3D; FilterType.CUSTOM,\n    classes &#x3D; &#123;TypeExcludeFilter.class&#125;\n), @Filter(\n    type &#x3D; FilterType.CUSTOM,\n    classes &#x3D; &#123;AutoConfigurationExcludeFilter.class&#125;\n)&#125;\n)\n\n\n@SpringBootConfiguration: Spring Boot的配置类; 标注在某个类上，表示这是一个Spring Boot的配置类；\n再进入该注解的源码可以看到我们的”老朋友”;\n@Target(&#123;ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Configuration\n\n\n@Configuration 这是Spring中配置类的注解\n@Target(&#123;ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Component\npublic @interface Configuration \n\n配置类也是容器中的一个组件, 因此其源码又有@Component\n\n\n\n\n\n@EnableAutoConfiguration: 自动配置注解\n以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效；\n@Target(&#123;ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(&#123;AutoConfigurationImportSelector.class&#125;)\npublic @interface EnableAutoConfiguration\n\n\n@AutoConfigurationPackage: 自动配置包\n@Target(&#123;ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@Import(&#123;Registrar.class&#125;)\npublic @interface AutoConfigurationPackage\n\n\n@import注解：Spring的底层注解@Import，给容器中导入一个组件\n导入的组件由org.springframework.boot.autoconfigure.AutoConfigurationPackages.Registrar将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；\n\n\n\n@Import(&#123;AutoConfigurationImportSelector.class&#125;)\nAutoConfigurationImportSelector.class将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；有了自动配置类，免去了我们手动编写配置注入功能组件等的工作;\n\n\nSpring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；以前我们需要自己配置的东西，自动配置类都帮我们完成了；\n\n\n","slug":"SpringBoot入门-HelloWorld","date":"2020-02-26T08:32:00.000Z","categories_index":"SpringBoot","tags_index":"笔记,SpringBoot","author_index":"Cao Wei"},{"id":"38a39c95773ebae43f0c0c8a85aadc04","title":"大数据线性回归预测学生成绩","content":"通过训练集训练和测试集测试来生成多个线性模型，从而预测学生成绩，本文所有代码请点击Github\n1. 实验数据背景1.1  数据来源本项目的数据来源于kaggle.com，数据集的名称为Student Grade Prediction，Paulo Cortez，Minho大学，葡萄牙吉马良斯，http：//www3.dsi.uminho.pt/pcortez\n1.2  数据简介该数据接近了两所葡萄牙学校的中学学生的学习成绩。数据属性包括学生成绩，人口统计学，社会和与学校相关的特征），并通过使用学校报告和调查表进行收集。提供了两个关于两个不同学科表现的数据集：数学（mat）和葡萄牙语（por）\n该数据集共有396条，每列33个属性，属性简介如下：\n\n\n1.学校-学生学校（二进制：“ GP”-加布里埃尔·佩雷拉（Gabriel Pereira）或“ MS”-Mousinho da Silveira）\n2.性别-学生的性别（二进制：“ F”-女性或“ M”-男性）\n3.年龄-学生的年龄（数字：15至22）\n4.地址-学生的家庭住址类型（二进制：“ U”-城市或“ R”-农村）\n5.famsize-家庭大小（二进制：“ LE3”-小于或等于3或“ GT3”-大于3）\n6.Pstatus-父母的同居状态（二进制：“ T”-同居或“ A”-分开）\n7.Medu-母亲的教育（数字：0-无，1-初等教育（四年级），2 – 5至9年级，3 –中等教育或4 –高等教育）\n8.Fedu-父亲的教育（数字：0-无，1-初等教育（四年级），2 – 5至9年级，3 –中等教育或4 –高等教育）\n9.Mjob-母亲的工作（名义：“教师”，“与健康”有关的，民事“服务”（例如行政或警察），“在家”或“其他”）\n10.Fjob-父亲的工作（名义：“教师”，“与健康”相关的，民事“服务”（例如行政或警察），“在家”或“其他”）\n11.理由-选择这所学校的理由（名义：接近“家”，学校“声誉”，“课程”偏好或“其他”）\n12.监护人-学生的监护人（名词：“母亲”，“父亲”或“其他”）\n13.traveltime-学校到学校的旅行时间（数字：1-&lt;15分钟，2-15至30分钟，3-30分钟至1小时或4-&gt; 1小时）\n14.学习时间-每周学习时间（数字：1-&lt;2小时，2-2至5小时，3-5至10小时或4-&gt; 10小时）\n15.失败-过去类失败的次数（数字：如果1 &lt;= n &lt;3，则为n，否则为4）\n16.schoolup-额外的教育支持（二进制：是或否）\n17.famsup-家庭教育支持（二进制：是或否）\n18.付费-课程主题内的额外付费课程（数学或葡萄牙语）（二进制：是或否）\n19.活动-课外活动（二进制：是或否）\n20.托儿所-上托儿所（二进制：是或否）\n21.更高-想要接受高等教育（二进制：是或否）\n22.互联网-在家上网（二进制：是或否）\n23.浪漫-具有浪漫关系（二进制：是或否）\n24.家族-家庭关系的质量（数字：从1-非常差到5-极好）\n25.空闲时间-放学后的空闲时间（数字：从1-非常低到5-非常高）\n26.外出-与朋友外出（数字：从1-非常低到5-非常高）\n27.Dalc-工作日酒精消耗（数字：从1-非常低到5-非常高）\n28.Walc-周末酒精消耗（数字：从1-非常低至5-非常高）\n29.健康-当前的健康状况（数字：从1-非常差到5-非常好）\n30.缺勤-缺勤人数（数字：0到93）\n这些成绩与课程主题（数学或葡萄牙语）相关：\n31.G1-第一期成绩（数字：0至20）\n32.G2-第二学期成绩（数字：0至20）\n33.G3-最终成绩（数字：0到20，输出目标）\n2. 研究思路数据集中存在不少非数值型数据，所以在进行建模之前要进行数据清洗，主要是抛弃掉一些非相关性数据以及缺失值处理，对数据进行分析的时候要注意其中是否有缺失值。\n一些机器学习算法能够处理缺失值，比如神经网络，一些则不能。对于缺失值，一般有以下几种处理方法：\n（1）如果数据集很多，但有很少的缺失值，可以删掉带缺失值的行；\n（2）如果该属性相对学习来说不是很重要，可以对缺失值赋均值或者众数。\n（3）对于标称属性，可以赋一个代表缺失的值，比如‘U0’。因为缺失本身也可能代表着一些隐含信息。\n（4）使用回归 随机森林等模型来预测缺失属性的值。因为Age在该数据集里是一个相当重要的特征（先对Age进行分析即可得知），所以保证一定的缺失值填充准确率是非常重要的，对结果也会产生较大影响。一般情况下，会使用数据完整的条目作为模型的训练集，以此来预测缺失值。对于当前的这个数据，可以使用随机森林来预测也可以使用线性回归预测。这里使用随机森林预测模型，选取数据集中的数值属性作为特征（因为sklearn的模型只能处理数值属性，所以这里先仅选取数值特征，但在实际的应用中需要将非数值特征转换为数值特征）\n数据规范化后方可进行数据分析，本项目将首先拿出一些特定属性，通过绘制图标的形式单独分析该属性反映出来的信息，试图分析该属性对结果的影响。\n最后将对全部数据建立线性模型，并把数据集分为训练集和测试集，以测试模型的准确性。\n3. 具体步骤3.1  数据总体分析利用padans库的read_csv函数，可以读取数据集：\n# 初始化数据\nplt.rcParams[&#39;font.sans-serif&#39;] &#x3D; [&#39;SimHei&#39;]  # 中文字体设置-黑体\nplt.rcParams[&#39;axes.unicode_minus&#39;] &#x3D; False  # 解决保存图像是负号&#39;-&#39;显示为方块的问题\nsns.set(font&#x3D;&#39;SimHei&#39;)  # 解决Seaborn中文显示问题\nstudent &#x3D; pd.read_csv(&#39;student-mat.csv&#39;)\n\n格式化后展示如图3-1-1\n\n图3-1-1数据格式化\n读取数据后，可以利用describe方法对单个属性分析，分析结果包括平均值，最值，标准差等，以G3属性为例，结果如图3-1-2所示\n\n\n图3-1-2 describe函数对单个属性分析\n### 3.2  利用图表分析属性\n\n3.2.1各分数段学生计数对学生期末成绩直接分析，可以得出成绩的大致分布，那么后文在分析其他因素对成绩的影响时也会更有针对性\n # 根据人数多少统计各分数段的学生人数 \n\ngrade_counts &#x3D; student[&#39;G3&#39;].value_counts().sort_values().plot.barh(width&#x3D;.9,color&#x3D;sns.color_palette(&#39;inferno&#39;,40)) \n\ngrade_counts.axes.set_title(&#39;各分数值的学生分布&#39;,fontsize&#x3D;30) \n\ngrade_counts.set_xlabel(&#39;学生数量&#39;, fontsize&#x3D;30) \n\ngrade_counts.set_ylabel(&#39;最终成绩&#39;, fontsize&#x3D;30) \n\nplt.show()\n\n绘制出的图像如图3-2-1所示：\n\n图3-2-1 各分数段学生统计图\n#### 3.2.2 学生成绩分布直方图\n\n3.2.1节中的图像并没有告诉我们有价值的信息，也许我们真正需要的是成绩分布直方图，即把成绩作为一个坐标轴，代码如下：\n# 从低到高展示成绩分布图 \ngrade_distribution &#x3D; sns.countplot(student[&#39;G3&#39;]) \ngrade_distribution.set_title(&#39;成绩分布图&#39;, fontsize&#x3D;30) \ngrade_distribution.set_xlabel(&#39;期末成绩&#39;, fontsize&#x3D;20) \ngrade_distribution.set_ylabel(&#39;人数统计&#39;, fontsize&#x3D;20) \nplt.show() \n\n绘制出的图像如图3-2-2所示：\n\n图3-2-2 期末成绩分布图\n可以看出得10分和11分的学生数量很多，虽然这只是一个中等成绩，大部分学生的成绩分布在8-15分之间。更值得注意的是，居然有接近40个人得了0分，不由得让我怀疑0其实是null值，但是在检查之后发现，确实是0值，外国学生这么菜？\n\n3.2.3 年龄因素分析中学生正处在身体机能快速发育的时期，大脑亦是如此，不同智力水平的学生势必会得到不同的分数，因此有必要分析一下年龄对成绩的影响，并且考虑到性别因素。\n以下代码可以得出性别的相关数据：\n# 分析性别比例 \n\nmale_studs &#x3D; len(student[student[&#39;sex&#39;] &#x3D;&#x3D; &#39;M&#39;]) \n\nfemale_studs &#x3D; len(student[student[&#39;sex&#39;] &#x3D;&#x3D; &#39;F&#39;]) \n\nprint(&#39;男同学数量:&#39;,male_studs) \n\nprint(&#39;女同学数量:&#39;,female_studs)\n\n结果为：男同学数量: 187，女同学数量: 208。男女比例并不悬殊。\n分析完性别因素之后，我们先来看看年龄比例的曲线图，代码如下：\n# 分析年龄分布比例（曲线图） \n\nage_distribution &#x3D; sns.kdeplot(student[&#39;age&#39;], shade&#x3D;True) \n\nage_distribution.axes.set_title(&#39;学生年龄分布图&#39;, fontsize&#x3D;30) \n\nage_distribution.set_xlabel(&#39;年龄&#39;, fontsize&#x3D;20) \n\nage_distribution.set_ylabel(&#39;比例&#39;, fontsize&#x3D;20) \n\nplt.show() \n\n生成的图像如图3-2-3所示：\n\n图3-2-3 年龄占比分布图\n该图反映出一个重要的信息，那就是绝大部分学的年龄都在15-19岁之间，但是除此之外没有其他有价值的信息，甚至看不出各个年龄段的人数，最重要的是没有考虑年龄，因此我又绘制的分性别的年龄分布直方图，代码如下：\n\n# 分性别年龄分布图（柱状图） \n\nage_distribution_sex &#x3D; sns.countplot(&#39;age&#39;, hue&#x3D;&#39;sex&#39;, data&#x3D;student) \n\nage_distribution_sex.axes.set_title(&#39;不同年龄段的学生人数&#39;, fontsize&#x3D;30) \n\nage_distribution_sex.set_xlabel(&#39;年龄&#39;, fontsize&#x3D;30) \n\nage_distribution_sex.set_ylabel(&#39;人数&#39;, fontsize&#x3D;30) \n\nplt.show() \n\n绘制的图像如图3-2-4所示：\n\n图3-2-4 分性别年龄分布图\n结果就是，其实大部分学生的年龄是在15-18岁之间，并且各个年龄段的男女比例基本正常。超过该年龄的学生不一定是离群值，而是有年级下降的学生。分析完年龄本身，接下就可以分析年龄对成绩的影响，首先作出各年龄段的成绩箱型图，代码如下：\n\n# 各年龄段的成绩箱型图 \n\nage_grade_boxplot &#x3D; sns.boxplot(x&#x3D;&#39;age&#39;, y&#x3D;&#39;G3&#39;, data&#x3D;student) \n\nage_grade_boxplot.axes.set_title(&#39;年龄与分数&#39;, fontsize &#x3D; 30) \n\nage_grade_boxplot.set_xlabel(&#39;年龄&#39;, fontsize &#x3D; 20) \n\nage_grade_boxplot.set_ylabel(&#39;分数&#39;, fontsize &#x3D; 20) \n\nplt.show() \n\n得到的图像如图3-2-5所示：\n\n图3-2-5 各年龄段的成绩箱型图\n绘制分布而非统计图将有助于我们更好地理解数据，代码如下：\n\n# 各年龄段的成绩分布图 \n\nage_grade_swarmplot &#x3D; sns.swarmplot(x&#x3D;&#39;age&#39;, y&#x3D;&#39;G3&#39;, data&#x3D;student) \n\nage_grade_swarmplot.axes.set_title(&#39;年龄与分数&#39;, fontsize &#x3D; 30) \n\nage_grade_swarmplot.set_xlabel(&#39;年龄&#39;, fontsize &#x3D; 20) \n\nage_grade_swarmplot.set_ylabel(&#39;分数&#39;, fontsize &#x3D; 20) \n\nplt.show() \n\n得到的图像如图3-2-6所示：\n\n图3-2-6 各年龄段的成绩分布图\n在15-18这个主要年龄段，学生成绩在各分数段的分布基本一致，我们可以得出学生年龄与成绩并没有直接的关系，或者说关系很弱。\n\n3.2.4 学生城乡因素分析既然年龄对成绩的影响不如预期那么明显，我们不妨再来分析一下学生地区因素对成绩的影响，在大部分地区，城乡教育资源都有不小的差距，教育质量也是如此，部分来自于乡下小学的孩子在步入城市中学后会不会落后于从小就在城市接受教育的孩子呢？\n首先分析城乡学生的比例，代码如下：\n# 城乡学生计数 \n\nareas_countplot &#x3D; sns.countplot(student[&#39;address&#39;]) \n\nareas_countplot.axes.set_title(&#39;城乡学生&#39;, fontsize &#x3D; 30) \n\nareas_countplot.set_xlabel(&#39;家庭住址&#39;, fontsize &#x3D; 20) \n\nareas_countplot.set_ylabel(&#39;计数&#39;, fontsize &#x3D; 20) \n\nplt.show() \n\n绘制的图像如图3-2-7所示：\n\n图3-2-7 城乡学生分布图\n​    大部分学生来自城市，并且城乡比例约为3 ：1。但是城市学生一定获得了更好的成绩吗？还需要进一步分析，代码如下：\n\nsns.kdeplot(student.loc[student[&#39;address&#39;] &#x3D;&#x3D; &#39;U&#39;, &#39;G3&#39;], label&#x3D;&#39;Urban&#39;, shade &#x3D; True) \n\nsns.kdeplot(student.loc[student[&#39;address&#39;] &#x3D;&#x3D; &#39;R&#39;, &#39;G3&#39;], label&#x3D;&#39;Rural&#39;, shade &#x3D; True) \n\nplt.title(&#39;城市学生获得了更好的成绩吗？&#39;, fontsize &#x3D; 20) \n\nplt.xlabel(&#39;分数&#39;, fontsize &#x3D; 20) \n\nplt.ylabel(&#39;占比&#39;, fontsize &#x3D; 20) \n\nplt.show() \n\n绘制出的图像如图3-2-8所示：\n\n图3-2-8 城乡学生成绩分布图\n城乡学生成绩分布曲线的差别微乎其微，可见家庭住址的不同没有对成绩造成太大的影响。\n\n3.3  各属性与成绩的相关性分析至此我们已经分析了年龄和地区这两个因素，然而并没有得到预期的结果——找出对成绩有影响的因素并分析原因，所以接下来我们综合分析各个因素与成绩之间的关系，希望会有好的结果。（注：仅限于数值属性）\n3.3.1相关性初步计算首先计算出各个属性与最终成绩G3的相关性，只需一行代码：\nstudent.corr()[‘G3’].sort_values() \n结果如下：\n\\1.  failures   -0.360415 \n\n\\2.  age     -0.161579 \n\n\\3.  goout    -0.132791 \n\n\\4.  traveltime  -0.117142 \n\n\\5.  health    -0.061335 \n\n\\6.  Dalc     -0.054660 \n\n\\7.  Walc     -0.051939 \n\n\\8.  freetime   0.011307 \n\n\\9.  absences   0.034247 \n\n\\10. famrel    0.051363 \n\n\\11. studytime   0.097820 \n\n\\12. Fedu     0.152457 \n\n\\13. Medu     0.217147 \n\n\\14. G1      0.801468 \n\n\\15. G2      0.904868 \n\n\\16. G3      1.000000 \n\n\\17. Name: G3, dtype: float64\n\n绝大部分机器学习算法无法处理非数值数据，因此在进行机器学习之前，我们要对部分属性进行编码。\n首先介绍一下编码方式，第一种是标签编码：\n此方法会为每个类别分配一个标签（label）\n\n\n\nOccupation\nLabel\n\n\n\nProgrammer\n0\n\n\nData  Scientist\n1\n\n\nEngineer\n2\n\n\n​    标签编码的问题是整数的分配是随机的，并且每次运行函数时都会改变。 此外，模型可能会为更大的标签赋予更高的优先级。当我们只有2个唯一值时，可以使用标签编码。\n第二种是独热编码：\n它为每个类别创建一个新列，并且仅使用二进制值。独热编码的缺点是，如果分类变量具有许多类别，则特征数量可能会爆炸。为了解决这个问题，我们可以执行PCA（或其他降维方法），然后执行独热编码。\n\n\n\nOccupation\nOccupation_prog\nOccupation_ds\nOccupation_eng\n\n\n\nProgrammer\n1\n0\n0\n\n\nData  Scientist\n0\n1\n0\n\n\nEnginner\n0\n0\n1\n\n\n3.3.2 编码后的相关性计算​    利用独热编码处理我们的数据集，然后再次寻找相关性，尽管G1和G2是学生的期末成绩，并且与期末成绩G3高度相关，但我们将其删除。没有G2和G1的情况下预测G3更加困难，但是这种预测更加有用，因为我们希望找到影响成绩的其他因素。代码如下：\n# 选取G3属性值 \n\nlabels &#x3D; student[&#39;G3&#39;] \n\n# 删除school，G1和G2属性 \n\nstudent &#x3D; student.drop([&#39;school&#39;, &#39;G1&#39;, &#39;G2&#39;], axis&#x3D;&#39;columns&#39;) \n\n# 对离散变量进行独热编码 \n\nstudent &#x3D; pd.get_dummies(student) \n\n# 选取相关性最强的6个 \n\nmost_correlated &#x3D; student.corr().abs()[&#39;G3&#39;].sort_values(ascending&#x3D;False) \n\nmost_correlated &#x3D; most_correlated[:6] \n\nprint(most_correlated) \n\n输出的结果如下：\n\\1.  G3       1.000000 \n\n\\2.  failures    0.360415 \n\n\\3.  Medu      0.217147 \n\n\\4.  higher_yes   0.182465 \n\n\\5.  higher_no   0.182465 \n\n\\6.  age      0.161579 \n\n\\7.  Fedu      0.152457  \n\n\\8.  Name: G3, dtype: float64 \n\n\n\n3.4  高相关度属性对成绩的影响3.4.1 失败次数对成绩的影响​    代码如下：\n# 失败次数成绩分布图 \n\nfailures_swarmplot &#x3D; sns.swarmplot(x&#x3D;student[&#39;failures&#39;],y&#x3D;student[&#39;G3&#39;]) \n\nfailures_swarmplot.axes.set_title(&#39;失败次数少的学生分数更高吗？&#39;, fontsize &#x3D; 30) \n\nfailures_swarmplot.set_xlabel(&#39;失败次数&#39;, fontsize &#x3D; 20) \n\nfailures_swarmplot.set_ylabel(&#39;最终成绩&#39;, fontsize &#x3D; 20) \n\nplt.show() \n\n生成的图像如图3-4-1所示：\n\n图3-4-1 失败次数对成绩的影响\n​    结果很明显，失败次数少的学生其成绩分布图更偏向于高分，可见失败次数少的学生更容易拿到高分，这或许是因为失败次数少的学生自信心更强。\n\n3.4.2 双亲受教育水平对成绩的影响​    代码如下：\n# 双亲受教育水平的影响 \n\nfamily_ed &#x3D; student[&#39;Fedu&#39;] + student[&#39;Medu&#39;]  \n\nfamily_ed_boxplot &#x3D; sns.boxplot(x&#x3D;family_ed,y&#x3D;student[&#39;G3&#39;]) \n\nfamily_ed_boxplot.axes.set_title(&#39;双亲受教育水平的影响&#39;, fontsize &#x3D; 30) \n\nfamily_ed_boxplot.set_xlabel(&#39;家庭教育水平(Mother + Father)&#39;, fontsize &#x3D; 20) \n\nfamily_ed_boxplot.set_ylabel(&#39;最终成绩&#39;, fontsize &#x3D; 20) \n\nplt.show() \n\n生成的图像如图3-4-2所示：\n\n图3-4-2 双亲受教育水平对成绩的影响\n​    可见在一定范围内，随着家庭教育水平的提升，学生的平均成绩也有所提升，但是在图表的两极却出现了规律的之外的东西，家庭受教育水平最低的学生，最终成绩高于不少其他水平的家庭，而家庭受教育水平最高的家庭，孩子的成绩却不是最高。原因暂时不明，且不排除数据错误的可能。\n\n3.4.3 学生升学意愿对成绩的影响高等教育是绝对变量，其值为是和否。 由于我们使用了独热编码，因此已将其转换为2个变量。 因此，我们可以消除其中之一（因为这些值是互补的）。 我们消除Higher_no，因为Higher_yes更直观。\n​    代码如下：\n# 学生自己的升学意志对成绩的影响 \n\npersonal_wish &#x3D; sns.boxplot(x &#x3D; student[&#39;higher_yes&#39;], y&#x3D;student[&#39;G3&#39;]) \n\npersonal_wish.axes.set_title(&#39;学生升学意愿对成绩的影响&#39;, fontsize &#x3D; 30) \n\npersonal_wish.set_xlabel(&#39;更高级的教育 (1 &#x3D; 是)&#39;, fontsize &#x3D; 20) \n\npersonal_wish.set_ylabel(&#39;最终成绩&#39;, fontsize &#x3D; 20) \n\nplt.show() \n\n生成的图像如图3-4-3所示：\n\n图3-4-3 学生自己的升学意志对成绩的影响\n显而易见，如果学生本人渴望受到更高的教育，其成绩也会更高一些，毕竟学习是自己的事情。\n3.5  大数据模型3.5.1   数据分割在大数据通过机器学习建立模型的过程中，不仅要使用大量的数据来训练模型，还需要一定数量的测试集验证模型的准确性，从而判断模型是否可用。因此，我们将数据集分割成训练集和测试集，比例分别为75%和25%。只需一行代码：\nX_train, X_test, y_train, y_test &#x3D; train_test_split(student, labels, test_size &#x3D; 0.25, random_state&#x3D;42) \n\n分割后我们便可以利用数据集进行线性回归模型的训练。\n3.5.2   训练之前的准备工作代码中的注释已经足够详细，不做解释，直接贴代码：\n# 计算平均绝对误差和均方根误差 \n\n# MAE-平均绝对误差 \n\n# RMSE-均方根误差 \n\ndef evaluate_predictions(predictions, true): \n\n    mae &#x3D; np.mean(abs(predictions - true)) \n\n    rmse &#x3D; np.sqrt(np.mean((predictions - true) ** 2)) \n\n     \n\n    return mae, rmse \n\n   \n\n # 求中位数 \n\n median_pred &#x3D; X_train[&#39;G3&#39;].median() \n\n  \n\n # 所有中位数的列表 \n\n median_preds &#x3D; [median_pred **for** _ **in** range(len(X_test))] \n\n  \n\n # 存储真实的G3值以传递给函数 \n\n true &#x3D; X_test[&#39;G3&#39;] \n\n  \n\n# 展示基准的原始指标 \n\n mb_mae, mb_rmse &#x3D; evaluate_predictions(median_preds, true) \n\nprint(&#39;Median Baseline MAE: &#123;:.4f&#125;&#39;.format(mb_mae)) \n\nprint(&#39;Median Baseline RMSE: &#123;:.4f&#125;&#39;.format(mb_rmse)) \n\n最后两句代码的运行结果为：\nMedian Baseline MAE: 3.7879\nMedian Baseline RMSE: 4.8252\n3.5.3   预测模型训练本项目将试图训练出六种模型，分别为：线性回归，ElasticNet回归，随机森林，极端随机数，支持向量机（SVM），梯度提升树。\n代码如下：\n# 通过训练集训练和测试集测试来生成多个线性模型\ndef evaluate(X_train, X_test, y_train, y_test):\n    # 模型名称\n    model_name_list &#x3D; [&#39;Linear Regression&#39;, &#39;ElasticNet Regression&#39;,\n                      &#39;Random Forest&#39;, &#39;Extra Trees&#39;, &#39;SVM&#39;,\n                       &#39;Gradient Boosted&#39;, &#39;Baseline&#39;]\n    X_train &#x3D; X_train.drop(&#39;G3&#39;, axis&#x3D;&#39;columns&#39;)\n    X_test &#x3D; X_test.drop(&#39;G3&#39;, axis&#x3D;&#39;columns&#39;)\n    \n    # 实例化模型\n    model1 &#x3D; LinearRegression()\n    model2 &#x3D; ElasticNet(alpha&#x3D;1.0, l1_ratio&#x3D;0.5)\n    model3 &#x3D; RandomForestRegressor(n_estimators&#x3D;100)\n    model4 &#x3D; ExtraTreesRegressor(n_estimators&#x3D;100)\n    model5 &#x3D; SVR(kernel&#x3D;&#39;rbf&#39;, degree&#x3D;3, C&#x3D;1.0, gamma&#x3D;&#39;auto&#39;)\n    model6 &#x3D; GradientBoostingRegressor(n_estimators&#x3D;50)\n    \n    # 结果数据框\n    results &#x3D; pd.DataFrame(columns&#x3D;[&#39;mae&#39;, &#39;rmse&#39;], index &#x3D; model_name_list)\n    \n    # 每种模型的训练和预测\n    for i, model in enumerate([model1, model2, model3, model4, model5, model6]):\n        model.fit(X_train, y_train)\n        predictions &#x3D; model.predict(X_test)\n        \n        # 误差标准\n        mae &#x3D; np.mean(abs(predictions - y_test))\n        rmse &#x3D; np.sqrt(np.mean((predictions - y_test) ** 2))\n        \n        # 将结果插入结果框\n        model_name &#x3D; model_name_list[i]\n        results.loc[model_name, :] &#x3D; [mae, rmse]\n    \n    # 中值基准度量\n    baseline &#x3D; np.median(y_train)\n    baseline_mae &#x3D; np.mean(abs(baseline - y_test))\n    baseline_rmse &#x3D; np.sqrt(np.mean((baseline - y_test) ** 2))\n    \n    results.loc[&#39;Baseline&#39;, :] &#x3D; [baseline_mae, baseline_rmse]\n    \n    return results\nresults &#x3D; evaluate(X_train, X_test, y_train, y_test)\nprint(results)\n\n结果如下表所示：\n\n\n\n模型名称\nMAE-平均绝对误差\nRMSE-均方根误差\n\n\n\nLinear Regression\n3.41954\n4.27557\n\n\nElasticNet Regression\n3.62976\n4.58258\n\n\nRandom Forest\n3.04111\n3.77742\n\n\nExtra Trees\n3.14586\n4.05109\n\n\nSVM\n3.50899\n4.38375\n\n\nGradient Boosted\n3.19128\n4.00822\n\n\nBaseline\n3.78788\n4.82523\n\n\n至此模型的训练已经完成，后续的分析将在第五节中呈现。\n4. 分析与总结模型训练完成之后，并非全部工作完成了，我们在第四节的最后训练出了多个模型，但是模型也有准确率之别，我们下一步就是要找出最合适的模型，代码如下:\n# 找出最合适的模型\nplt.figure(figsize&#x3D;(12, 8))\n\n# 平均绝对误差\nax &#x3D;  plt.subplot(1, 2, 1)\nresults.sort_values(&#39;mae&#39;, ascending &#x3D; True).plot.bar(y &#x3D; &#39;mae&#39;, color &#x3D; &#39;b&#39;, ax &#x3D; ax, fontsize&#x3D;20)\nplt.title(&#39;平均绝对误差&#39;, fontsize&#x3D;20) \nplt.ylabel(&#39;MAE&#39;, fontsize&#x3D;20)\n\n# 均方根误差\nax &#x3D; plt.subplot(1, 2, 2)\nresults.sort_values(&#39;rmse&#39;, ascending &#x3D; True).plot.bar(y &#x3D; &#39;rmse&#39;, color &#x3D; &#39;r&#39;, ax &#x3D; ax, fontsize&#x3D;20)\nplt.title(&#39;均方根误差&#39;, fontsize&#x3D;20) \nplt.ylabel(&#39;RMSE&#39;,fontsize&#x3D;20)\nplt.tight_layout()\nplt.show()\n\n生成的图像如图4-1所示：\n\n图4-1 各模型误差柱状图\n显然，无论是平均绝对误差还是均方根误差，线性回归模型都是最小的。因此我们对它进行保存，以便于以后调用，代码很简单：\n\n*\n# 保存线性回归模型*\n\nmodel &#x3D; LinearRegression()\n\nmodel.fit(X_train, y_train)\n\nfilename &#x3D; &#39;LR_Model&#39;\n\npickle.dump(model, open(filename, &#39;wb&#39;)) \n\n至此，建立大数据模型的工作已经全部完毕，并且保存了我们训练好的模型，以后如果想预测某个学生的成绩，只要将相关属性输入模型即可得出预测结果。\n回过头来再想一下，大数据学习的初衷是数据分析，因此在建立模型之前，有必要对单个属性先进行一些分析，毕竟在某些数据集中可能会存在一些影响性大甚至是决定性的属性。但对属性分析不意味着随便拿属性分析，除了理性选择之外，我们最好提前把数据进行编码，然后分析各个属性的相关性，选取一些相关性较高的属性分析。比如本项目中，失败次数，学生个人升学意愿对学生的成绩影响非常明显。\n需要强调的是，基于大数据的预测并不是绝对准确的，很多时候由于各种原因可能会造成离谱的误差，因此它只是我们预测结果的参考值。\n","slug":"大数据线性回归预测学生成绩","date":"2019-12-21T10:29:00.000Z","categories_index":"大数据,算法","tags_index":"算法,大数据","author_index":"Cao Wei"},{"id":"70047dfd85b8c57f6b791b919373d4bb","title":"【算法】Python判断数字是否是回文数","content":"回文数的定义：回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n\n示例1：\n输入：121\n输出：True\n示例2：\n输入：-121\n输出：False\n解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n示例3：\n输入: 10\n输出: false\n解释: 从右向左读, 为 01 。因此它不是一个回文数。\n思路：\n映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。\n第二个想法是将数字本身反转，但是这样做有一个风险，32位机器的int类型最大值为2147483647，反转后的数字可能超出范围造成溢出。\n按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int\\text{int}int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。\n例如，输入 1221，我们可以将数字“1221”的后半部分从“21”反转为“12”，并将其与前半部分“12”进行比较，因为二者相同，我们得知数字 1221 是回文。\n算法：\n首先我们要处理一些特殊情况，负数不可能是回文数，首先要禁止负数进入。\n然后再考虑如何反转数字，例如1221，首先1221%10就可以得到最后一位数字1，然后将1221/10得到122，再次122%10得到倒数第二位数字2，最后用1*10+2=12就得到了我们反转后的数字12，用12和原数字的前两位对比即可判断该数字是不是回文数。\n还存在一个问题：我们怎么知道自己反转了一半呢？\n我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。\n代码实现：\nPython \n\nclass Solution(object):    \n\tdef isPalindrome(self, x):        \n\t\t&quot;&quot;&quot;        \n\t\t:type x: int        \n\t\t:rtype: bool        \n\t\t&quot;&quot;&quot;        \n\t\tif x&lt;0 or (x % 10 &#x3D;&#x3D; 0 and x !&#x3D; 0):            \t\t\treturn False        \n\t\ty&#x3D;0        \n\t\twhile(x&gt;y):            \n\t\t\ty&#x3D;x%10+y*10            \n\t\t\tx &#x2F;&#x3D; 10;        \n\t\treturn x&#x3D;&#x3D;y or x&#x3D;&#x3D;y&#x2F;10 \n\nJava \n    \nclass Solution &#123;    \n    public boolean isPalindrome(int x) &#123;        \n        if(x &lt; 0 || (x % 10 &#x3D;&#x3D; 0 &amp;&amp; x !&#x3D; 0))            \t\treturn false;        \n        int res &#x3D; 0;        \n        while(x &gt; res)&#123;            \n            res &#x3D; res * 10 + x % 10;            \n            x &#x2F;&#x3D; 10;        \n        &#125;        \n        return x &#x3D;&#x3D; res || x &#x3D;&#x3D; res &#x2F; 10;    \n    &#125; \n&#125; \n\n","slug":"【算法】Python判断数字是否是回文数","date":"2019-12-12T03:56:00.000Z","categories_index":"算法","tags_index":"算法","author_index":"Cao Wei"},{"id":"65c55b1dd6ea4c2ed4b7b7ff7aa16c28","title":"关于我","content":"我是菜鸟，欢迎赐教：Github: Wavecao\nQQ: 2353769789\n微信：C2353769789\n","slug":"关于我","date":"2019-12-11T03:56:00.000Z","categories_index":"关于我","tags_index":"2019","author_index":"Cao Wei"}]